#!/bin/bash
#
# SAPHana
#
# Description:  Manages two SAP HANA Databases in System Replication
#               Planned: do also manage scale-out scenarios
#               currently the SAPHana is dependent of the analysis of
#               SAPHanaTopology
#               For supported scenarios please read the README file provided
#               in the same software package (rpm)
#
##############################################################################
#
# SAPHana
# Author:       Fabian Herschel, November 2013
# Support:      linux@sap.com
# License:      GNU General Public License (GPL)
# Copyright:    (c) 2013,2014 SUSE Linux Products GmbH
# Copyright:    (c) 2015-2024 SUSE LLC
#
# An example usage:
#      See usage() function below for more details...
#
# OCF instance parameters:
#   OCF_RESKEY_SID
#   OCF_RESKEY_InstanceNumber
#   OCF_RESKEY_DIR_EXECUTABLE   (optional, well known directories will be searched by default)
#   OCF_RESKEY_DIR_PROFILE      (optional, well known directories will be searched by default)
#   OCF_RESKEY_INSTANCE_PROFILE (optional, well known directories will be searched by default)
#   OCF_RESKEY_PREFER_SITE_TAKEOVER (optional, default is no)
#   OCF_RESKEY_DUPLICATE_PRIMARY_TIMEOUT (optional, time difference needed between two last-primary-tiemstampe (lpt))
#   new instance parameter for the RA
#   OCF_RESKEY_REMOVE_SAP_SOCKETS (optional, default is true)
#   OCF_RESKEY_SAPHanaFilter    (outdated, replaced by cluster property hana_${sid}_glob_filter)
#
# HANA must support the following commands:
#     hdbnsutil -sr_stateConfiguration (unsure, if this means >= SPS110, SPS111 or SPS10x)
#     hdbnsutil -sr_takeover
#     hdbnsutil -sr_register
#     landscapeHostConfiguration.py
#     systemReplicationStatus.py (>= SPS090)
#
#######################################################################
SAPHanaVersion="0.162.3"
#
# Initialization:
: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/lib/heartbeat}
. ${OCF_FUNCTIONS_DIR}/ocf-shellfuncs

#
#######################################################################
#
log_attributes=false
if ocf_is_true "$log_attributes"; then
    log_attr_file="/var/log/fhATTRIBUTES"
else
    log_attr_file="/dev/null"
fi

HANA_STATE_PRIMARY=0
HANA_STATE_SECONDARY=1
HANA_STATE_STANDALONE=2
HANA_STATE_DEFECT=3
HANA_STD_ACTION_TIMEOUT=3600

debug_attributes=0

SH=/bin/sh

#
# function: super_ocf_log - wrapper function for ocf log in order catch usual logging into super log
# params:   LOG_MESSAGE
# globals:  SAPHanaFilter
function super_ocf_log() {
    local level="$1"
    local message="$2"
    local skip=1
    local mtype=""
    local shf="${SAPHanaFilter:-all}"
    #ocf_log "info" "super_ocf_log: f:$shf l:$level m:$message"
    # message levels: (dbg)|info|warn|err|error
    # message types:  (ACT|RA|FLOW|DBG|LPA|DEC|DBG2...
    case "$level" in
        debug | dbg | warn | err | error ) skip=0
        ;;
        info )
        case "$shf" in
            all) skip=0
            ;;
            none )
                skip=1
                ;;
            * ) mtype=${message%% *}
                mtype=${mtype%:}
                [[ ${shf} == *${mtype}* ]] && skip=0 || skip=1
            ;;
        esac
        ;;
    esac
    if [ $skip -eq 0 ]; then
        ocf_log "$level" "$message"
    fi
}

#
# function: saphana_usage - short usage info
# params:   -
# globals:  $0(r)
#
function saphana_usage() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    methods=$(saphana_methods)
    methods=$(echo $methods | tr ' ' '|')
    echo "    usage: $0 ($methods)

    $0 manages two SAP HANA databases (scale-up) in system replication.

    The 'start'        operation starts the HANA instance or bring the \"clone instance\" to a WAITING status
    The 'stop'         operation stops the HANA instance
    The 'status'       operation reports whether the HANA instance is running
    The 'monitor'      operation reports whether the HANA instance seems to be working in multi-state it also needs to check the system replication status
    The 'promote'      operation either runs a takeover for a secondary or a just-nothing for a primary
    The 'demote'       operation nearly does nothing and just mark the instance as demoted
    The 'notify'       operation always returns SUCCESS
    The 'validate-all' operation reports whether the parameters are valid
    The 'methods'      operation reports on the methods $0 supports
    The 'reload'       operation allows to adapt resource parameters
"
    return $rc
}

function backup_global_and_nameserver() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    cp /hana/shared/${SID}/global/hdb/custom/config/global.ini /hana/shared/${SID}/global/hdb/custom/config/global.ini.$(date +"%s")
    cp /hana/shared/${SID}/global/hdb/custom/config/nameserver.ini /hana/shared/${SID}/global/hdb/custom/config/nameserver.ini.$(date +"%s")
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_meta_data - print resource agent meta-data for cluster
# params:   -
# globals:  -
#
function saphana_meta_data() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    echo '<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="SAPHana" version="'$SAPHanaVersion'">
<version>1.0</version>

<shortdesc lang="en">Manages two SAP HANA database systems in system replication (SR).</shortdesc>
<longdesc lang="en">
The SAPHanaSR resource agent manages two SAP HANA database systems which are configured
in system replication. SAPHana supports Scale-Up scenarios.

Managing the two SAP HANA database systems means that the resource agent controls the start/stop of the
instances. In addition the resource agent is able to monitor the SAP HANA databases to check their
availability on landscape host configuration level. For this monitoring the resource agent relies on interfaces
provided by SAP. A third task of the resource agent is to also check the synchronisation status
of the two SAP HANA databases. If the synchronisation is not "SOK", then the cluster avoids to
failover to the secondary side, if the primary fails. This is to improve the data consistency.

The resource agent uses the following four interfaces provided by SAP:

1. sapcontrol/sapstartsrv
   The interface sapcontrol/sapstartsrv is used to start/stop a HANA database instance/system

2. landscapeHostConfiguration
   The interface is used to monitor a HANA system. The python script is named landscapeHostConfiguration.py.
   landscapeHostConfiguration.py has some detailed output about HANA system status
   and node roles. For our monitor the overall status is relevant. This overall
   status is reported by the return code of the script:
   0: Internal Fatal, 1: ERROR, 2: WARNING, 3: INFO, 4: OK
   The SAPHana resource agent will interpret return codes 0 as FATAL, 1 as not-running or ERROR and and returncodes 2+3+4 as RUNNING.

3. hdbnsutil
   The interface hdbnsutil is used to check the "topology" of the system replication as well as the current configuration
   (primary/secondary) of a SAP HANA database instance. A second task of the interface is the possibility to run a
   system replication takeover (sr_takeover) or to register a former primary to a newer one (sr_register).

4. hdbsql / systemReplicationStatus
   Interface is SQL query into HANA (system replication table).  The hdbsql query will be replaced by a python script
   "systemReplicationStatus.py" in SAP HANA SPS8 or 9.
   As long as we need to use hdbsql you need to set up secure store users for linux user root to be able to
   access the SAP HANA database. You need to configure a secure store user key "SAPHANA'${SID}'SR" which can connect the SAP
   HANA database:

5. saphostctrl
   The interface saphostctrl uses the function ListInstances to figure out the virtual host name of the
   SAP HANA instance. This is the hostname used during the HANA installation.

</longdesc>
<parameters>
    <parameter name="SID" unique="0" required="1">
        <longdesc lang="en">SAP System Identifier (SID) like "SLE" or "HAE"</longdesc>
        <shortdesc lang="en">SAP System Identifier (SID)</shortdesc>
        <content type="string" default="" />
    </parameter>
    <parameter name="InstanceNumber" unique="0" required="1">
        <longdesc lang="en">SAP instance number like "00" or "07"</longdesc>
        <shortdesc lang="en">SAP instance number</shortdesc>
        <content type="string" default="" />
    </parameter>
    <parameter name="PREFER_SITE_TAKEOVER" unique="0" required="0">
        <longdesc lang="en">Should cluster/RA prefer to switchover to secondary instance instead of restarting primary locally? Default="false"
        no: Do prefer restart locally
        yes: Do prefer takeover to remote site
        never: Do never run a sr_takeover (promote) at the secondary side. THIS VALUE IS CURRENTLY NOT SUPPORTED.
        </longdesc>
        <shortdesc lang="en">Local or site recover preferred?</shortdesc>
        <content type="string" default="false" />
    </parameter>
    <parameter name="REMOVE_SAP_SOCKETS" unique="0" required="0">
        <longdesc lang="en">Should the RA remove the unix domain sockets related to sapstartsrv before (re-)starting sapstartsrv ? Default="true"
        no: Do not remove the sockets, try chown/chgrp instead
        yes: Do remove the sockets
        </longdesc>
        <shortdesc lang="en">Remove unix domain sockets related to sapstartsrv?</shortdesc>
        <content type="boolean" default="true" />
    </parameter>
    <parameter name="AUTOMATED_REGISTER"  unique="0" required="0">
        <shortdesc lang="en">Define, if a former primary should automatically be registered.</shortdesc>
        <longdesc lang="en">The parameter AUTOMATED_REGISTER defines, whether a former primary instance should
             be registered automatically by the resource agent during cluster/resource start, if  the DUPLICATE_PRIMARY_TIMEOUT is expired... TDB
        </longdesc>
        <content type="boolean" default="false" />
    </parameter>
    <parameter name="DUPLICATE_PRIMARY_TIMEOUT" unique="0" required="0">
        <shortdesc lang="en">Time difference needed between to primary time stamps, if a dual-primary situation occurs</shortdesc>
        <longdesc lang="en">Time difference needed between to primary time stamps,
        if a dual-primary situation occurs. If the time difference is
        less than the time gap, then the cluster holds one or both instances in a "WAITING" status. This is to give an admin
        a chance to react on a failover. A failed former primary will be registered after the time difference is passed. After
        this registration to the new primary all data will be overwritten by the system replication.
        </longdesc>
        <content type="string" default="7200" />
    </parameter>
    <parameter name="HANA_CALL_TIMEOUT" unique="0" required="0">
        <shortdesc lang="en">Define timeout how long a call to HANA to receive information can take.</shortdesc>
        <longdesc lang="en">Define timeout how long a call to HANA to receive information can take. This could be eg landscapeHostConfiguration.py.
          There are some specific calls to HANA which have their own timeout values. For example the takeover command does not timeout (inf).
          If the timeout is reached, the return code will be 124. If you increase the timeouts for HANA calls you should also adjust the operation timeouts
          of your cluster resources.
        </longdesc>
        <content type="string" default="60" />
    </parameter>
    <parameter name="DIR_EXECUTABLE" unique="0" required="0">
        <longdesc lang="en">The full qualified path where to find sapstartsrv and sapcontrol. Specify this parameter, if you have changed the SAP kernel directory location after the default SAP installation.</longdesc>
        <shortdesc lang="en">Path of sapstartsrv and sapcontrol</shortdesc>
        <content type="string" default="" />
    </parameter>
    <parameter name="DIR_PROFILE" unique="0" required="0">
        <longdesc lang="en">The full qualified path where to find the SAP START profile. Specify this parameter, if you have changed the SAP profile directory location after the default SAP installation.</longdesc>
        <shortdesc lang="en">Path of start profile</shortdesc>
        <content type="string" default="" />
    </parameter>
    <parameter name="INSTANCE_PROFILE" unique="1" required="0">
        <longdesc lang="en">The name of the SAP HANA instance profile. Specify this parameter, if you have changed the name of the SAP HANA instance profile after the default SAP installation. Normally you do not need to set this parameter.</longdesc>
        <shortdesc lang="en">HANA instance profile name</shortdesc>
        <content type="string" default="" />
    </parameter>
    <parameter name="SAPHanaFilter" unique="0" required="0">
        <shortdesc lang="en">OUTDATED PARAMETER</shortdesc>
        <longdesc lang="en">OUTDATED PARAMETER</longdesc>
        <content type="string" default="" />
    </parameter>
</parameters>

<actions>
    <action name="start"   timeout="3600" />
    <action name="stop"    timeout="3600" />
    <action name="status"  timeout="60" />
    <action name="monitor" depth="0" timeout="700" interval="120" />
    <action name="monitor" depth="0" timeout="700" interval="121" role="Slave" />
    <action name="monitor" depth="0" timeout="700" interval="119" role="Master" />
    <action name="promote" timeout="3600" />
    <action name="demote"  timeout="320" />
    <action name="validate-all" timeout="5" />
    <action name="meta-data" timeout="5" />
    <action name="methods" timeout="5" />
    <action name="reload" timeout="5" />
</actions>
</resource-agent>'
super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
return $rc
}

#
# function: saphana_methods - report supported cluster methods
# params:   -
# globals:  -
# methods: What methods/operations do we support?
#
function saphana_methods() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0 m
    for m in start stop status monitor promote demote notify validate-all methods meta-data usage reload; do
        echo "$m"
    done
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: dequote - filter: remove quotes (") from stdin
# params:   -
# globals:  -
function dequote()
{
    local rc=0; tr -d '"'; return $rc
}

# function: version: compare two HANA version strings
function ver_lt() {
    ocf_version_cmp $1 $2
    test $? -eq 0 && return 0 || return 1
}

function ver_le() {
    ocf_version_cmp $1 $2
    test $? -eq 0 -o $? -eq 1 && return 0 || return 1
}

function ver_gt() {
    ocf_version_cmp $1 $2
    test $? -eq 2 && return 0 || return 1
}

function ver_ge() {
    ocf_version_cmp $1 $2
    test $? -eq 2 -o $? -eq 1 && return 0 || return 1
}
#
# function: version: compare two HANA version strings
#
function version() {
    if [ $# -eq 3 ]; then
        case "$2" in
            LE | le | "<=" ) ver_le $1 $3;;
            LT | lt | "<" ) ver_lt $1 $3;;
            GE | ge | ">=" ) ver_ge $1 $3;;
            GT | gt | ">" ) ver_gt $1 $3;;
            * ) return 1;
        esac
    elif [ $# -ge 5 ]; then
        version $1 $2 $3 && shift 2 && version $*
    else
        return 1;
    fi
}

#
# function: remoteHost2remoteNode - convert a SAP remoteHost to the cluster node name
# params:   remoteHost
# globals:  ATTR_NAME_HANA_VHOST[*]
#
function remoteHost2remoteNode()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local -a clusterNodes=()
    local cl=""
    local vHost=""
    local remoteHost="$1"
    local remoteNode=""
    local rc=1
    for cl in ${otherNodes[@]}; do
        vHost=$(get_hana_attribute $cl  "${ATTR_NAME_HANA_VHOST[@]}" "$cl")
        if [ "$vHost" = "$remoteHost" ]; then # we found the correct node
            remoteNode=$cl
            rc=0
        fi
    done
    if [ -n "$remoteNode"  ]; then
        echo "$remoteNode"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

# function: get_action_timeout
# output:  action timeout
#
# timeOut = max(3600, 95%(actionTimeOut))
#
function get_action_timeout() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    # $OCF_RESKEY_CRM_meta_timeout is the timeout of the current running action in ms
    local actionTimeOut="$OCF_RESKEY_CRM_meta_timeout"
    local stdTimeOut="$HANA_STD_ACTION_TIMEOUT"
    local actTimeOutPercent=95 # 95% to left 5% for the rest of the resource agent action
    if [ -z "$actionTimeOut" ]; then
        actionTimeOut="$stdTimeOut"
    else
        # actionTimeOut in seconds
        ((actionTimeOut = actionTimeOut/1000))
    fi

    # 95%(actionTimeOut)
    ((timeout = actionTimeOut * actTimeOutPercent/100))
    # max(3600, 95%(actionTimeOut))
    if [ -z "$timeout" ] || [ "$timeout" -lt "$stdTimeOut" ]; then
        timeout=$stdTimeOut
    fi
    super_ocf_log info "actionTimeout: action timeout was '$actionTimeOut', now changed to '$timeout'"
    super_ocf_log info "FLOW $FUNCNAME"
    echo $timeout
}

#
# function: is_clone - report, if resource is configured as a clone (also multi-state)
# params:   -
# globals:  OCF_*(r)
# descript: is_clone : find out if we are configured to run in a multi-state configuration
# rc: 0: it is a clone, 1: it is not a clone
#
# DONE: PRIO2: For the first shipment (scale-out) we need to limit the clones to 2
#
function is_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    #
    # is a clone config?
    #
    if [ -n "$OCF_RESKEY_CRM_meta_clone_max" ] \
       && [ "$OCF_RESKEY_CRM_meta_clone_max" -gt 0 ]; then
       #
       # yes it is a clone config - check, if its configured well
       #
        if [ "$OCF_RESKEY_CRM_meta_clone_node_max" -ne 1 ] || \
            [ "$OCF_RESKEY_CRM_meta_clone_max" -ne 2 ] || \
            [ "$OCF_RESKEY_CRM_meta_master_node_max" -ne 1 ] || \
            [ "$OCF_RESKEY_CRM_meta_master_max" -ne 1 ]; then
                super_ocf_log err "ACT: Clone options misconfigured. (expect: clone_max=2,clone_node_max=1,master_node_max=1,master_max=1)"
                exit $OCF_ERR_CONFIGURED
        fi
        rc=0;
    else
        rc=1;
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: get_hana_attribute
# params:   NODE ATTR [STORE]
# globals:  -
# output:   attribute value
#
function get_hana_attribute()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local attr_node=$1
    local attr_name=$2
    local attr_store=${3:-reboot} # DONE: PRIO5 get this (optional) from parameter
    local attr_default=${4:-}
    local dstr
    local attr_val=""
    dstr=$(date)
    case "$attr_store" in
        reboot | forever )
            if ocf_is_true "$log_attributes"; then
                echo "$dstr: SAPHana: crm_attribute -N ${attr_node} -G -n \"$attr_name\" -l $attr_store -q" >> $log_attr_file
            fi
            crm_attribute -N ${attr_node} -G -n "$attr_name" -l $attr_store -q -d "$attr_default" 2>>$log_attr_file; rc=$?
            ;;
        props )
            if ocf_is_true "$log_attributes"; then
                echo "$dstr: SAPHana: crm_attribute -G -n \"$attr_name\" -t crm_config -q" >> $log_attr_file
            fi
            crm_attribute -G -n "$attr_name" -t crm_config -q -d "$attr_default" 2>>$log_attr_file; rc=$?
            ;;
    esac
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: set_hana_attribute - set the multi-state status of a node
# params:   NODE VALUE ATTR [STORE [DEFAULT]]
# globals:  -
#
function set_hana_attribute()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local attr_node=$1
    local attr_value=$2
    local attr_name=$3
    local attr_store=${4:-reboot} # DONE: PRIO5 get this (optional) from parameter
    local attr_default=${5:-}
    local rc=1
    local attr_old=""
    attr_old=$(get_hana_attribute $attr_node $attr_name $attr_store $attr_default); get_rc=$?
    if [ "$attr_old" != "$attr_value" ]; then
        super_ocf_log debug "DBG: SET attribute $attr_name for node ${attr_node} to ${attr_value} former ($attr_old) get_rc=$get_rc "
        dstr=$(date)
        case "$attr_store" in
            reboot | forever )
                if ocf_is_true "$log_attributes"; then
                    echo "$dstr: SAPHana: crm_attribute -N $attr_node -v \"$attr_value\" -n \"$attr_name\" -l $attr_store" >> $log_attr_file
                fi
                crm_attribute -N $attr_node -v "$attr_value" -n "$attr_name" -l $attr_store 2>>$log_attr_file; rc=$?
                ;;
            props )
                if ocf_is_true "$log_attributes"; then
                    echo "$dstr: SAPHana: crm_attribute -v \"$attr_value\" -n \"$attr_name\" -t crm_config -s SAPHanaSR" >> $log_attr_file
                fi
                crm_attribute -v "$attr_value" -n "$attr_name" -t crm_config  -s SAPHanaSR 2>>$log_attr_file; rc=$?
                ;;
        esac
    else
        super_ocf_log debug "DBG: LET attribute $attr_name for node ${attr_node} still be ${attr_value}"
        rc=0
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: assert - quickly go out of here with minimal error/return code handling and log
# params:   MESSAGE
# globals:  OCF_*(r)
#
function assert() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local err_msg=$1
    local default_rc=$OCF_NOT_RUNNING
    # DONE: Check, if we need to distinguish between probe and others
    if ocf_is_probe; then
        default_exit=$OCF_NOT_RUNNING
    else
        default_exit=$OCF_ERR_CONFIGURED
    fi
    if [ "$ACTION" = "stop" ]; then
        cleanup_instance
        exit $OCF_SUCCESS
    fi
    super_ocf_log err "ACT: $err_msg"
    exit $OCF_NOT_RUNNING
}

#
# function: set_crm_master - set the crm master score of the local node
# params:   SCORE
# globals:  HA_SBIN_DIR(r), OCF_RESOURCE_INSTANCE(r)
#
function set_crm_master()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local score=0
    if [ -n "$1" ]; then
        score=$1
    fi
    # DONE: PRIO2: Only adjust master if value is really different (try to check that)
    oldscore=$(${HA_SBIN_DIR}/crm_master -G -q -l reboot)
    if [ "$oldscore" != "$score" ]; then
       dstr=$(date)
       if ocf_is_true "$log_attributes"; then
           echo "$dstr: SAPHana: crm_master -v $score -l reboot " >> $log_attr_file
       fi
       super_ocf_log debug "DBG: SET crm master: $score (old: $oldscore)"
       ${HA_SBIN_DIR}/crm_master -v $score -l reboot; rc=$?
    else
       super_ocf_log debug "DBG: LET crm master: $score"
       rc=0
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: scoring_crm_master - score instance due to role and sync match (table SCORING_TABLE)
# params:   NODE_ROLES NODE_SYNC_STATUS
# globals:  SCORING_TABLE[@],
#
scoring_crm_master()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local roles="$1"
    local sync="$2"
    local myScore=''
    for scan in "${SCORING_TABLE[@]}"; do
        # $scan needs "" to prevent globbing, as the scoring tables include '.*'
        read rolePatt syncPatt score < <(echo "$scan")
        if [[ "$roles" =~ $rolePatt ]] ; then
            # $syncPatt must NOT have "" for correct matching
            if [[ "$sync" =~ $syncPatt ]] ; then
                super_ocf_log info "DEC: scoring_crm_master: roles($roles) are matching pattern ($rolePatt)"
                super_ocf_log info "DEC: scoring_crm_master: sync($sync) is matching syncPattern ($syncPatt)"
                super_ocf_log info "DEC: scoring_crm_master: set score $score"
                myScore=$score
                break
            fi
        fi
    done
    super_ocf_log debug "DBG: scoring_crm_master adjust score $myScore"
    # DONE: PRIO1: DO Not Score, If we did not found our role/sync at this moment - bsc#919925
    if [ -n "$myScore" ]; then
        set_crm_master $myScore
    fi
}

#
# function: get_crm_master - get the crm master score of the local node
# params:   -
# globals:  HA_SBIN_DIR(r)
#
function get_crm_master()
{
  super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
  local rc=0
   ${HA_SBIN_DIR}/crm_master -G -q -l reboot; rc=$?

   super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
   return $rc
}

#
# function: HANA_CALL
# params:   timeout-in-seconds cmd-line
# globals:  sid(r), SID(r), InstanceName(r)
#
function HANA_CALL()
{
    #
    # TODO: PRIO 5: remove 'su - ${sidadm} later, when SAP HANA resoled issue with
    #       root-user-called hdbnsutil -sr_state (which creates root-owned shared memory file in /var/lib/hdb/SID/shmgrp)
    #       would hdbnsutil -sr_stateConfiguration also create such a shared memory file?
    # TODO: PRIO 5: Maybe make "su" optional by a parameter
    local timeOut=0
    local onTimeOut=""
    local rc=0
    local use_su=1 # Default to be changed later (see TODO above)
    local pre_cmd=""
    local cmd=""
    local pre_script=''
    local output=""
    while [ $# -gt 0 ]; do
        case "$1" in
            --timeout ) timeOut=$2; shift;;
            --use-su  ) use_su=1;;
            --on-timeout ) onTimeOut="$2"; shift;;
            --cmd ) shift; cmd="$*"; break;;
        esac
        shift
    done

    if [ $use_su -eq 1 ]; then
        pre_cmd="su - ${sid}adm -c"
        [[ $cmd == python* ]] && pre_script=": [$$]; cd $DIR_EXECUTABLE/python_support" || pre_script=": [$$]"
    else
        # as root user we need the library path to the SAP kernel to be able to call sapcontrol
        # check, if we already added DIR_EXECUTABLE at the beginning of LD_LIBRARY_PATH
        if [ "${LD_LIBRARY_PATH%%*:}" != "$DIR_EXECUTABLE" ]
        then
            MY_LD_LIBRARY_PATH=$DIR_EXECUTABLE${LD_LIBRARY_PATH:+:}$LD_LIBRARY_PATH
        fi
        pre_cmd="bash -c"
        pre_script="LD_LIBRARY_PATH=$MY_LD_LIBRARY_PATH; export LD_LIBRARY_PATH"
    fi
    case $timeOut in
        0 | inf )
                  output=$($pre_cmd "$pre_script; $cmd"); rc=$?
                  ;;
        *       )
                  errExt=$(date '+%s%N')_${sid}adm
                  su_err_log=${SAPHanaSR_RUN}/HANA_CALL_SU_RA_${errExt}
                  cmd_out_log=${SAPHanaSR_RUN}/HANA_CALL_CMD_RA_OUT_${errExt}
                  cmd_err_log=${SAPHanaSR_RUN}/HANA_CALL_CMD_RA_${errExt}

                  output=$(timeout --foreground -s 9 "$timeOut" $pre_cmd "($pre_script; timeout -s 9 $timeOut $cmd > $cmd_out_log) >& $cmd_err_log" 2>"$su_err_log"); rc=$?

                  output=$(if [ -f "$cmd_out_log" ]; then cat "$cmd_out_log"; rm -f "$cmd_out_log"; fi)
                  suErr=$(if [ -f "$su_err_log" ]; then cat "$su_err_log"; rm -f "$su_err_log"; else echo "NA"; fi)
                  cmdErr=$(if [ -f "$cmd_err_log" ]; then cat "$cmd_err_log"; rm -f "$cmd_err_log"; else echo "NA"; fi)
                  super_ocf_log debug "DBG: RA ==== action HANA_CALL (cmd is '$cmd', rc is '$rc', stderr from su is '$suErr', stderr from cmd is '$cmdErr') ===="
                  # on rc=1 - retry to improve the behavior in AD environments
                  if [ $rc -eq 1 ]; then
                      super_ocf_log warn "RA: HANA_CALL stderr from command '$pre_cmd' is '$suErr', stderr from command '$cmd' is '$cmdErr'"
                      if [ "$cmdErr" == "NA" ]; then
                          # seems something was going wrong with the 'pre_cmd' (su)
                          super_ocf_log warn "DEC: HANA_CALL returned '1' for command '$pre_cmd'. Retry once."
                          output=$(timeout --foreground -s 9 "$timeOut" $pre_cmd "$pre_script; timeout -s 9 $timeOut $cmd"); rc=$?
                      fi
                  fi
                  #
                  # on timeout ...
                  #
                  if [ $rc -eq 124 ]; then
                      super_ocf_log warn "RA: HANA_CALL timed out after $timeOut seconds running command '$cmd'"
                  fi
                  if [ $rc -eq 124 -a -n "$onTimeOut" ]; then
                      local second_output=""
                      second_output=$($pre_cmd "$pre_script; $onTimeOut");
                  fi
                 ;;
    esac
    super_ocf_log debug "DBG: HANA_CALL '$cmd' rc=$rc output=$output"
    echo "$output"
    return $rc;
}

#
# function get_SRHOOK_plain
# fetches site specific Hook SR status ONLY
# globals: ATTR_NAME_HANA_SRHOOK[@](r)
# locals:  ATTR[@], my_sync, get_sr_name
#
function get_SRHOOK_plain()
{
    local -a ATTR my_sync
    local get_sr_name="$1"
    ATTR=("${ATTR_NAME_HANA_SRHOOK[@]}"); ATTR[0]="${ATTR[0]}_$get_sr_name"
    my_sync=$(get_hana_attribute "X" "${ATTR[@]}")
    super_ocf_log info "DEC: ${ATTR[0]}=$my_sync"
    echo "$my_sync"
    return 0
}

#
# function get_SRHOOK
# fetches site specific Hook SR status or (as fallback) the polling-attribute
# params: site-name site-host
# globals: ATTR_NAME_HANA_SRHOOK[@](r), ATTR_NAME_HANA_SYNC_STATUS[@](r)
# locals:  ATTR[@], my_sync, get_sr_name, get_sr_host
#
function get_SRHOOK()
{
    local -a ATTR my_sync
    local get_sr_name="$1"
    local get_sr_host="$2"
    ATTR=("${ATTR_NAME_HANA_SRHOOK[@]}"); ATTR[0]="${ATTR[0]}_$get_sr_name"
    my_sync=$(get_hana_attribute "X" "${ATTR[@]}")
    super_ocf_log info "DEC: ${ATTR[0]}=$my_sync"
    if [ -z "$my_sync" -o "$my_sync" = "SWAIT" ]; then
        my_sync=$(get_hana_attribute "$get_sr_host" "${ATTR_NAME_HANA_SYNC_STATUS[@]}")
        super_ocf_log info "DEC: ${ATTR[0]} is empty or SWAIT. Take polling attribute: ${ATTR_NAME_HANA_SYNC_STATUS[0]}=$my_sync"
    fi
    if [ -z "$my_sync" ]; then   # be pesimistic, if we could not determine the SR attribute
        my_sync="SFAIL"
    fi
    super_ocf_log info "DEC: Finally get_SRHOOK()=$my_sync"
    echo "$my_sync"
    return 0
}

#
# function set_SRHOOK - sets the site specific Hook SR status
# params: site-name, value
# globals: ATTR_NAME_HANA_SRHOOK[@](r), ATTR_NAME_HANA_SYNC_STATUS[@](r)
# locals:  ATTR[@], my_sync, get_sr_name
# SAPHanaSR Scale-Up already uses multi-target aware SR Hook attribute there is not global fallback attribute
#
function set_SRHOOK()
{
    local -a ATTR my_sync old_sync
    local get_sr_name="$1"
    local value="$2"
    ATTR=("${ATTR_NAME_HANA_SRHOOK[@]}"); ATTR[0]="${ATTR[0]}_$get_sr_name"
    set_hana_attribute "X" "$value" "${ATTR[@]}"
    return 0
}

#
# function set_SRHOOK_PRIM - sets the site specific Hook SR status
# params: site-name, value
# globals: ATTR_NAME_HANA_SRHOOK[@](r), ATTR_NAME_HANA_SYNC_STATUS[@](r)
# locals:  ATTR[@], my_sync, get_sr_name
# SAPHanaSR Scale-Up already uses multi-target aware SR Hook attribute there is not global fallback attribute
#
function set_SRHOOK_PRIM()
{
    local lastSrHook
    local lastRemSrHook
    # to be backward compatible only set the site attribute, if the local or remote site attribute is already used (set) in the past
    lastSrHook=$(get_SRHOOK_plain "$sr_name")
    lastRemSrHook=$(get_SRHOOK_plain "$remSR_name")
    if [ -n "${lastSrHook}${lastRemSrHook}" ]; then
        # reset srHook attribute to PRIM as we found either local or remore srHook attribute
        set_SRHOOK "$sr_name" "PRIM"
    fi
}

#
# function: saphana_init - initialize variables for the resource agent
# params:   InstanceName
# globals:  OCF_*(r), SID(w), sid(rw), sidadm(w), InstanceName(w), InstanceNr(w), SAPVIRHOST(w), PreferSiteTakeover(w),
# globals:  sr_name(w), remoteHost(w), otherNodes(w), remSR_name(w)
# globals:  ATTR_NAME_HANA_SYNC_STATUS(w), ATTR_NAME_HANA_CLONE_STATE(w)
# globals:  DIR_EXECUTABLE(w), SAPSTARTSRV(w), SAPCONTROL(w), DIR_PROFILE(w), SAPSTARTPROFILE(w), LD_LIBRARY_PATH(w), PATH(w)
# globals:  LPA_DIRECTORY(w), SIDInstanceName(w), remoteNode(w), hdbSrQueryTimeout(w)
# globals:  NODENAME(w), vNAME(w), hdbver(w),
# saphana_init : Define global variables with default values, if optional parameters are not set
#
function saphana_init() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=$OCF_SUCCESS
    local clN
    SYSTEMCTL="/usr/bin/systemctl"
    # local site
    # two parameter models (for transition only)
    # OLD: InstanceName
    # NEW: SID InstanceNumber
    NODENAME=$(crm_node -n)
    SID=$OCF_RESKEY_SID
    InstanceNr=$OCF_RESKEY_InstanceNumber
    SIDInstanceName="${SID}_HDB${InstanceNr}"
    InstanceName="HDB${InstanceNr}"
    export SAPSYSTEMNAME=$SID
    HANA_CALL_TIMEOUT="${OCF_RESKEY_HANA_CALL_TIMEOUT:-60}"
    super_ocf_log debug "DBG: Used new method to get SID ($SID) and InstanceNr ($InstanceNr)"
    sid="${SID,,}"
    sidadm="${sid}adm"
    # create subdirectory in /run
    SAPHanaSR_RUN="/run/SAPHanaSR_${sid}"
    mkdir -p $SAPHanaSR_RUN
    chown $sidadm $SAPHanaSR_RUN
    # TODO PRIO3: Do we need a parameter for the RA to be able to adjust hdbSrQueryTimeout?
    hdbSrQueryTimeout=180
    # DONE: PRIO4: SAPVIRHOST might be different to NODENAME
    # DONE: PRIO1: ASK: Is the output format of ListInstances fix? Could we take that as an API? Answer: Yes
    # try to catch:  Inst Info : LNX - 42 - lv9041 - 740, patch 36, changelist 1444691
    # We rely on the following format: SID is word#4, SYSNR is word#6, vHost is word#8
    if [ -e /usr/sap/hostctrl/exe/saphostctrl ]; then
        vName=$(/usr/sap/hostctrl/exe/saphostctrl -function ListInstances \
            | awk '$4 == SID && $6 == SYSNR { print $8 }' SID=$SID SYSNR=$InstanceNr 2>/dev/null )
        super_ocf_log debug "DBG: ListInstances: $(/usr/sap/hostctrl/exe/saphostctrl -function ListInstances)"
    else
        super_ocf_log error "ERR: SAPHOSTAGENT is not installed at /usr/sap/hostctrl/exe (saphostctrl missing)"
    fi
    if [ -z "$vName" ]; then
       #
       # if saphostctrl does not know the answer, try to fallback to attribute provided by SAPHanaTopology
       #
       vName=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_VHOST[@]}" "$NODENAME");
    fi
    if [ -z "$vName" ]; then # last fallback if we are not able to figure out the virtual host name
       vName="$NODENAME"
    fi
    SAPVIRHOST=${vName}
    PreferSiteTakeover="$OCF_RESKEY_PREFER_SITE_TAKEOVER"
    AUTOMATED_REGISTER="${OCF_RESKEY_AUTOMATED_REGISTER:-false}"
    RemoveSAPSockets="${OCF_RESKEY_REMOVE_SAP_SOCKETS:-true}"
    LPA_DIRECTORY=/var/lib/SAPHanaRA
    LPA_ATTR=("lpa_${sid}_lpt" "forever")
    super_ocf_log debug "DBG: SID=$SID, sid=$sid, SIDInstanceName=$SIDInstanceName, InstanceName=$InstanceName, InstanceNr=$InstanceNr, SAPVIRHOST=$SAPVIRHOST"
    ocf_env=$(env | grep 'OCF_RESKEY_CRM')
    super_ocf_log debug "DBG: OCF: $ocf_env"
    #
    ATTR_NAME_HANA_SYNC_STATUS=("hana_${sid}_sync_state" "reboot")  # SOK, SFAIL, UNKNOWN?
    ATTR_NAME_HANA_PRIMARY_AT=("hana_${sid}_primary_at"   "reboot") # Not used so far
    ATTR_NAME_HANA_CLONE_STATE=("hana_${sid}_clone_state" "reboot") # UKNOWN?, DEMOTED, PROMOTED
    ATTR_NAME_HANA_REMOTEHOST=("hana_${sid}_remoteHost" "forever")
    ATTR_NAME_HANA_SITE=("hana_${sid}_site" "forever")
    ATTR_NAME_HANA_ROLES=("hana_${sid}_roles" "reboot")
    ATTR_NAME_HANA_SRMODE=("hana_${sid}_srmode" "forever")
    ATTR_NAME_HANA_VHOST=("hana_${sid}_vhost" "forever")
    ATTR_NAME_HANA_STATUS=("hana_${sid}_status" "reboot")
    ATTR_NAME_HANA_OPERATION_MODE=("hana_${sid}_op_mode" "forever")
    ATTR_NAME_HANA_SRACTION=("hana_${sid}_sra" "reboot") # Marks, if cluster in a phase requesting  a takeover (T) or registration (R)
    ATTR_NAME_HANA_SRACTION_HISTORY=("hana_${sid}_srah" "reboot") # Marks, if cluster in a phase requesting  a takeover (T) or registration (R)
    #
    # new "central" attributes
    #
    ATTR_NAME_HANA_FILTER=("hana_${sid}_glob_filter" "props" "ra-act-dec-lpa")
    SAPHanaFilter=$(get_hana_attribute "X" "${ATTR_NAME_HANA_FILTER[@]}")
    #
    # SITE based attributes
    #
    ATTR_NAME_HANA_SRHOOK=("hana_${sid}_site_srHook" "props")                    # external triggered SOK, SFAIL
    #
    # TODO: PRIO4: Table for non-preferred-site-takeover
    #
    SCORING_TABLE_PREFERRED_SITE_TAKEOVER=(
       "[234]*:P:[^:]*:master .*     150"
       "[234]*:P:master       .*     140"
       "[015-9]*:P:[^:]*:master .*    90"
       "[0-9]*:P:[^:]*:slave  .*      60"
       "[234]*:P:[^:]*:[?:-]  .*       0"
       "[015-9]*:P:[^:]*:[?:-]  .*    -1"
       "[234]*:S:[^:]*:master SOK    100"
       "[234]*:S:[^:]*:master PRIM   100"
       "[015-9]*:S:[^:]*:master SOK   80"
       "[0-9]*:S:[^:]*:master SFAIL  -INFINITY"
       "[0-9]*:S:[^:]*:slave  SOK     10"
       "[0-9]*:S:[^:]*:slave  SFAIL  -INFINITY"
       "[234]*:S:[^:]*:[?:-]  .*       0"
       "[015-9]*:S:[^:]*:[?:-] .*     -1"
       ".*                    .*      -1"
    )
    SCORING_TABLE_PREFERRED_LOCAL_RESTART=(
       "[0-9]*:P:[^:]*:master .*     150"
       "[0-9]*:P:[^:]*:.*     .*     140"
       "[0-9]*:S:[^:]*:master SOK    100"
       "[0-9]*:S:[^:]*:master PRIM   100"
       "[0-9]*:S:[^:]*:master SFAIL  -INFINITY"
       "[0-9]*:S:[^:]*:slave  SOK     10"
       "[0-9]*:S:[^:]*:slave  SFAIL  -INFINITY"
       "[015-9]*:S:[^:]*:[?:-]  .*    -1"
       "[234]*:S:[^:]*:[?:-]    .*    -1"
       ".*                      .*    -1"
    )
    SCORING_TABLE_PREFERRED_NEVER=(
       "[234]*:P:[^:]*:master .*     150"
       "[015-9]*:P:[^:]*:master .*    90"
       "[0-9]*:P:[^:]*:.*     .*     -INFINITY"
       "[0-9]*:S:[^:]*:.*     .*     -INFINITY"
       ".*                    .*     -INFINITY"
    )
    if ocf_is_true $PreferSiteTakeover; then
        SCORING_TABLE=("${SCORING_TABLE_PREFERRED_SITE_TAKEOVER[@]}")
    else
        case "$PreferSiteTakeover" in
            never|NEVER|Never )
                SCORING_TABLE=("${SCORING_TABLE_PREFERRED_NEVER[@]}")
                ;;
            * )
                SCORING_TABLE=("${SCORING_TABLE_PREFERRED_LOCAL_RESTART[@]}")
                ;;
        esac
    fi
    #
    DUPLICATE_PRIMARY_TIMEOUT="${OCF_RESKEY_DUPLICATE_PRIMARY_TIMEOUT:-7200}"
    super_ocf_log debug "DBG: DUPLICATE_PRIMARY_TIMEOUT=$DUPLICATE_PRIMARY_TIMEOUT"
    #
    # Determine list of other cluster nodes and store in otherNodes variable
    otherNodes=()
    case $(crm_attribute --type crm_config --name cluster-infrastructure -q) in
       *corosync* ) otherNodes=($(crm_node -l | awk '{ if ($2 != me) { print $2 }}' me="${NODENAME}"));;
       *openais* ) otherNodes=($(crm_node -l | awk '$3 == "member" { if ($2 != me) { print $2 }}' me="${NODENAME}"));;
       *cman*    ) otherNodes=($(crm_node -l | awk '{for (i=1; i<=NF; i++) { if ($i != me) { print $i }}}' me="${NODENAME}"));;
    esac
    #
    #
    #
    remoteHost=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_REMOTEHOST[@]}");
    if [ -z "$remoteHost" ]; then
       if [ "${#otherNodes[@]}" -eq 1 ]; then # we are a 2 node cluster, lets assume the other is the remote-host
          remoteNode="${otherNodes[0]}"
          remoteHost=$(get_hana_attribute "$remoteNode" "${ATTR_NAME_HANA_VHOST[@]}" "$remoteNode");
          super_ocf_log debug "DBG: auto-guess remoteHost=$remoteHost"
       else
          super_ocf_log debug "DBG: Could not auto-guess remoteHost out of list (${otherNodes[@]})"
       fi
    else
        #
        # search cluster node which vhost is equal remoteHost
        #
        remoteNode=$(remoteHost2remoteNode "$remoteHost")
        # TODO: PRIO5: catch rc!=0
    fi
    #  ATTR_NAME_HANA_SITE
    sr_name=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_SITE[@]}");
    sr_mode=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_SRMODE[@]}")

    if [ -z "$sr_mode" ]; then
        sr_mode="sync"
    fi
    if [ -n "$remoteNode" ]; then
        remSR_name=$(get_hana_attribute "${remoteNode}" "${ATTR_NAME_HANA_SITE[@]}");
    else

        for clN in "${otherNodes[@]}"; do
            nodeSite=$(get_hana_attribute "$clN" "${ATTR_NAME_HANA_SITE[@]}")
            if [ -n "$nodeSite" -a "$nodeSite" != "$sr_name" ]; then
                remSite="$nodeSite"
                remSR_name="${remSite%%:*}"
                remSR_id="${remSite#*:}"
            fi
        done
    fi
    super_ocf_log debug "DBG: sr_name=$sr_name, remoteHost=$remoteHost, remoteNode=$remoteNode, sr_mode=$sr_mode"
    # optional OCF parameters, we try to guess which directories are correct
    if  [ -z "$OCF_RESKEY_DIR_EXECUTABLE" ]
    then
        if have_binary /usr/sap/$SID/$InstanceName/exe/sapstartsrv && have_binary /usr/sap/$SID/$InstanceName/exe/sapcontrol
        then
            DIR_EXECUTABLE="/usr/sap/$SID/$InstanceName/exe"
        fi
    else
        if have_binary "$OCF_RESKEY_DIR_EXECUTABLE/sapstartsrv" && have_binary "$OCF_RESKEY_DIR_EXECUTABLE/sapcontrol"
        then
            DIR_EXECUTABLE="$OCF_RESKEY_DIR_EXECUTABLE"
        fi
    fi
    SAPSTARTSRV="$DIR_EXECUTABLE/sapstartsrv"
    SAPCONTROL="$DIR_EXECUTABLE/sapcontrol"

    [ -z "$DIR_EXECUTABLE" ] && assert "Cannot find sapstartsrv and sapcontrol executable, please set DIR_EXECUTABLE parameter!"
    DIR_PROFILE="${OCF_RESKEY_DIR_PROFILE:-/usr/sap/$SID/SYS/profile}"
    # check, if the following fall-back is ok, or if there could be multiple profiles matching this pattern
    if [ -n "${SAPVIRHOST}" ]; then
        SAPSTARTPROFILE="$DIR_PROFILE/${OCF_RESKEY_INSTANCE_PROFILE:-${SID}_${InstanceName}_${SAPVIRHOST}}"
    else
        # check, if the following fall-back is ok, or if there could be multiple profiles matching this pattern
        # also take profile versions into account - they might break this fall-back
        # TODO: PRIO4: Check, if it makes sense to implement an additional last fall-back: get the SAPSTARTPROFILE from /usr/sap/sapservices
        #
        SAPSTARTPROFILE="$(ls -1 $DIR_PROFILE/${OCF_RESKEY_INSTANCE_PROFILE:-${SID}_${InstanceName}_*})"
    fi
    #PATH=${PATH}:${DIR_EXECUTABLE}; export PATH
    #
    # get HANA version
    #
    local ges_ver
    ges_ver=$(grep -s -m1 -oP 'fullversion: \K.+(?= Build)' "/usr/sap/$SID/$InstanceName/exe/manifest")
    #fallback
    [[ -z ${ges_ver:-} ]] && ges_ver=$(HANA_CALL --timeout 10 --cmd "HDB version" | tr -d " " | awk -F: '$1 == "version" {print $2}')
    #Version xx.yy.zzz
    [[ ${ges_ver} =~ [0-9]+(\.[0-9]+){2} ]] && hdbver=${BASH_REMATCH[0]}

    #
    # since rev 111.00 we should use a new hdbnsutil option to get the -sr_state
    # since rev 112.03 the old option is changed and we should use -sr_stateConfiguration where ever possible
    #
    hdbState="hdbnsutil -sr_stateConfiguration"
    # DONE: PRIO1: Beginning from SAP HANA rev 112.03 -sr_state is not longer supported
    if version "$hdbver" "<" "1.00.111"; then
        hdbState="hdbnsutil -sr_state"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$OCF_SUCCESS"
    return $OCF_SUCCESS
}

# function: check_secstore_users
# params:   USER
# globals:  DIR_EXECUTABLE(r)
#
# TODO: PRIO5: Might be dropped, if we get a script for fetching the sync status
function check_secstore_users()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local user=""
    local rc=1
    while [ $# -gt 0 ]; do
        user="$1"
        $DIR_EXECUTABLE/hdbuserstore list | grep -q "KEY $user" && echo "$user" && rc=0 && break
        shift
    done
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

# chk4systemdsupport - check, if SAP systemd support is available
# check for the existence of the SAP SID+Instance related unit file
# rc=0 - sap instance unit file exists
# rc=1 - sap instance unit file does NOT exist
function chk4systemdsupport() {
    super_ocf_log info "FLOW ${FUNCNAME[0]}"
    local systemd_unit_name="SAP${SID}_${InstanceNr}.service"
    local rc=1
    if [ -x "$SYSTEMCTL" ]; then
        if [ -f /etc/systemd/system/"$systemd_unit_name" ]; then
            rc=0
        elif $SYSTEMCTL list-unit-files | \
            awk '$1 == service { found=1 } END { if (! found) {exit 1}}' service="${systemd_unit_name}"; then
            rc=0
        else
            rc=1
        fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# handle_unix_domain_sockets
# params: -
# globals: OCF_RESKEY_REMOVE_SAP_SOCKETS
#
handle_unix_domain_sockets() {
    super_ocf_log info "FLOW ${FUNCNAME[0]}"

    if ocf_is_true "$RemoveSAPSockets"; then
        # previous and new default handling
        # removing the unix domain socket files as they might have
        # wrong permissions or ownership
        # they will be recreated by sapstartsrv during next start
        rm -f /tmp/.sapstream5"${InstanceNr}"13
        rm -f /tmp/.sapstream5"${InstanceNr}"14
    else
        # try to change permission and ownership of the unix domain socket files
        for sockFile in /tmp/.sapstream5"${InstanceNr}"13 /tmp/.sapstream5"${InstanceNr}"14; do
            sockError=false
            if [ -S "$sockFile" ]; then
                if ! chown "${sid}"adm "$sockFile" > /dev/null 2>&1; then
                    sockError=true
                fi
                if ! chgrp sapsys "$sockFile" > /dev/null 2>&1; then
                    sockError=true
                fi
                if chmod 700 "$sockFile" > /dev/null 2>&1; then
                    sockError=true
                fi
            else
                if [ -f "$sockFile" ]; then
                    super_ocf_log error "RA: file '$sockFile' still exists, but is NO longer a socket."
                    super_ocf_log info "DEC: remove file '$sockFile' to give sapstartsrv a chance to create it the right way during next start"
                    sockError=true
                else
                    super_ocf_log info "RA: file '$sockFile' not found. Nothing to do, let sapstartsrv create a new one during start"
                fi
            fi
            if ocf_is_true $sockError; then
                # fallback - if there are Errors, remove unix domain socket as
                # last resort
                rm -f "$sockFile"
            fi
        done
    fi
}

#
# function: check_sapstartsrv - check for sapstartsrv - optional start
# params:   -
# globals:  DIR_PROFILE(w), SAPSTARTPROFILE(r), SAPCONTROL(r), SID(r), InstanceName(r), InstanceNr(r), OCF_*(r)
# check_sapstartsrv : Before using sapcontrol we make sure that the sapstartsrv is running.
#
function check_sapstartsrv() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local restart=0
    local runninginst=""
    local rc=$OCF_SUCCESS
    local output=""
    if chk4systemdsupport; then
        # use systemd to control sapstartsrv
        local systemd_unit_name="SAP${SID}_${InstanceNr}.service"

        if $SYSTEMCTL is-active --quiet "$systemd_unit_name"; then
            super_ocf_log info "ACT: systemd service $systemd_unit_name is active"
        else
            super_ocf_log warn "ACT: systemd service $systemd_unit_name is not active, it will be started using systemd"
            # use start, because restart does also stop sap instance
            $SYSTEMCTL start "$systemd_unit_name" >/dev/null 2>&1; src=$?
            if [ $src -ne 0 ]; then
                super_ocf_log error "ACT: error during start of systemd unit ${systemd_unit_name}!"
                rc=$OCF_ERR_GENERIC
                ocf_is_probe && rc=$OCF_NOT_RUNNING
            fi
        fi
    else
        # no SAP systemd unit available, continue with old code...
        if [ ! -S "/tmp/.sapstream5${InstanceNr}13" ]; then
            super_ocf_log warn "ACT: sapstartsrv is not running for instance $SID-$InstanceName (no UDS), it will be started now"
            restart=1
        else
            output=$($SAPCONTROL -nr "$InstanceNr" -function ParameterValue INSTANCE_NAME -format script)
            if [ $? -eq 0 ]
            then
                runninginst=$(echo "$output" | grep '^0 : ' | cut -d' ' -f3)
                if [ "$runninginst" != "$InstanceName" ]
                then
                    super_ocf_log warn "ACT: sapstartsrv is running for instance $runninginst, that service will be killed"
                    restart=1
                else
                    output=$($SAPCONTROL -nr "$InstanceNr" -function AccessCheck Start)
                    if [ $? -ne 0 ]; then
                        super_ocf_log warn "ACT: FAILED - sapcontrol -nr $InstanceNr -function AccessCheck Start ($(ls -ld1 /tmp/.sapstream5${InstanceNr}13))"
                        super_ocf_log warn "ACT: sapstartsrv will be restarted to try to solve this situation, otherwise please check sapstsartsrv setup (SAP Note 927637)"
                        restart=1
                    fi
                fi
            else
                super_ocf_log warn "ACT: sapstartsrv is not running for instance $SID-$InstanceName, it will be started now"
                restart=1
            fi
        fi
        if [ -z "$runninginst" ]; then runninginst=$InstanceName; fi
        if [ $restart -eq 1 ]
        then
            if [ -d /usr/sap/$SID/SYS/profile/ ]
            then
                DIR_PROFILE="/usr/sap/$SID/SYS/profile"
            else
                assert "Expected /usr/sap/$SID/SYS/profile/ to be a directory, please set DIR_PROFILE parameter!"
            fi
            [ ! -r "$SAPSTARTPROFILE" ] && assert "Expected $SAPSTARTPROFILE to be the instance START profile, please set INSTANCE_PROFILE parameter!"
            pkill -9 -f "sapstartsrv.*$runninginst"

            handle_unix_domain_sockets
            (
              export PATH="$DIR_EXECUTABLE${PATH:+:}$PATH"
              export LD_LIBRARY_PATH="$DIR_EXECUTABLE${LD_LIBRARY_PATH:+:}$LD_LIBRARY_PATH"
              $SAPSTARTSRV pf="$SAPSTARTPROFILE" -D -u "$sidadm"
            )
            # now make sure the daemon has been started and is able to respond
            local srvrc=1
            while [ $srvrc -eq 1 -a $(pgrep -f "sapstartsrv.*$runninginst" | wc -l) -gt 0 ]
            do
                sleep 1
                $SAPCONTROL -nr $InstanceNr -function GetProcessList > /dev/null 2>&1
                srvrc=$?
            done
            if [ $srvrc -ne 1 ]
            then
                super_ocf_log info "ACT: sapstartsrv for instance $SID-$InstanceName was restarted!"
                rc=$OCF_SUCCESS
            else
                super_ocf_log error "ACT: sapstartsrv for instance $SID-$InstanceName could not be started!"
                rc=$OCF_ERR_GENERIC
                ocf_is_probe && rc=$OCF_NOT_RUNNING
            fi
        fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: cleanup_instance - remove resources from a crashed instance
# params:   -
# globals:  -
#
function cleanup_instance() {
  super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
  local rc=0
  # TODO: PRIO5: Check, if we need HANA cleanup procedure (processes, ipc obj, pid files); Currently not needed
  super_ocf_log debug "DBG: cleanup_instance currently not implemented"
  rc=0
  super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
}

#
# function: check_for_primary - check if local SAP HANA is configured as primary
# params:   -
# globals:  HANA_STATE_PRIMARY(r), HANA_STATE_SECONDARY(r), HANA_STATE_DEFECT(r)
#
function check_for_primary() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=$HANA_STATE_DEFECT
    # TODO: PRIO 3: Check beginning from which SPS does SAP support HDBSettings.sh?
    # DONE: Limit the runtime of hdbnsutil and use getParameter.py as fallback
    # DONE: PRIO2: Maybe we need to use a fallback interface when hdbnsutil does not answer properly -> lookup in config files?
    # TODO:        This might also solve some problems when we could not figure-out the local or remote site name (site_name,site_id from global.ini)
    local chkMethod=""
    local node_status=""
    local node_full_status=""
    local i=0
    for chkMethod in  hU hU hU gP; do
        case "$chkMethod" in
            gP )
                # fallback for 'hdbnsutil' failing 3 times.
                local gpKeys=""
                gpKeys=$(echo --key=global.ini/system_replication/{actual_mode,mode})
                node_full_status=$(HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "python getParameter.py $gpKeys --sapcontrol=1" 2>&1)
                # first try to get the value of 'actual_mode' from the global.ini
                [[ "$node_full_status" =~ "SAPCONTROL-OK: <begin>".*"/actual_mode="([^$'\n']*).*"SAPCONTROL-OK: <end>" ]] && node_status=${BASH_REMATCH[1]}
                # if 'actual_mode' is not available, fallback to 'mode'
                if [ -z "$node_status" ]; then
                    [[ "$node_full_status" =~ "SAPCONTROL-OK: <begin>".*"/mode="([^$'\n']*).*"SAPCONTROL-OK: <end>" ]] && node_status=${BASH_REMATCH[1]}
                fi
                super_ocf_log info "ACT: Using getParameter.py as fallback - node_status=$node_status"
                ;;
            hU | * )
                node_full_status=$(HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "$hdbState --sapcontrol=1" 2>/dev/null )
                [[ "$node_full_status" =~ "SAPCONTROL-OK: <begin>".*(^|$'\n')"mode="([^$'\n']*).*"SAPCONTROL-OK: <end>" ]] && node_status=${BASH_REMATCH[2]}
                super_ocf_log debug "DBG: check_for_primary: node_status=$node_status"
                ;;
        esac
        case "$node_status" in
            primary )
                rc=$HANA_STATE_PRIMARY
                break;;
            syncmem | sync | async )
                rc=$HANA_STATE_SECONDARY
                break;;
            none ) # have seen that mode on second side BEFEORE we registered it as replica
                rc=$HANA_STATE_STANDALONE
                break;;
            * )
                super_ocf_log err "ACT: check_for_primary:  we didn't expect node_status to be: <$node_status>"
                if [ -n "$node_status" ]; then
                    dump=$( echo -n $node_status | hexdump -C );
                    super_ocf_log err "ACT: check_for_primary:  we didn't expect node_status to be: DUMP <$dump>"
                fi
                ((i++))
                super_ocf_log debug "DEC: check_for_primary: loop=$i: node_status=$node_status"
                # TODO: PRIO1: Maybe we need to keep the old value for P/S/N, if hdbnsutil just crashes
                # lets pause a bit to give hdbnsutil a chance to answer next time
                sleep 2
                ;;
        esac
    done
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

# function: analyze_hana_sync_statusSRS
# params:   -
# globals:  DIR_EXECUTABLE(r), FULL_SR_STATUS(w), remoteNode, remSR_name
#
# systemReplicationStatus.py return-codes:
#    NoHSR        = 10
#    Error        = 11
#    Unknown      = 12
#    Initializing = 13
#    Syncing      = 14
#    Active       = 15
function analyze_hana_sync_statusSRS()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=-1 srRc=0 all_nodes_other_side="" n="" siteParam=""
    if [ -n "$remSR_name" ]; then
       siteParam="--site=$remSR_name"
    fi
    # TODO: Get rid of the su by using a new interface:
    # SAPSYSTEMNAME=SLE /usr/sap/SLE/HDB00/HDBSettings.sh systemReplicationStatus.py $siteParam
    # TODO: Check beginning from which SPS does SAP support HDBSettings.sh?
    # TODO: Limit the runtime of systemReplicationStatus.py
    # SAP_CALL
    FULL_SR_STATUS=$(HANA_CALL --timeout 5 --cmd "python systemReplicationStatus.py $siteParam" 2>/dev/null); srRc=$?
    super_ocf_log info "DEC ${FUNCNAME[0]} systemReplicationStatus.py (to site '$remSR_name')-> $srRc"
    super_ocf_log info "FLOW ${FUNCNAME[0]} systemReplicationStatus.py (to site '$remSR_name')-> $srRc"
    #
    # TODO: PRIO2: Here we might also need to filter additional sites (if multi tier should be supported)
    #              And is the check for return code capable for chains?
    #
    if [ $srRc -eq 15 ]; then
       # Fix for a HANA BUG, where a non-working SR resulted in RC 15:
       if [[ $FULL_SR_STATUS == *ACTIVE* ]]; then
          super_ocf_log info "FLOW ${FUNCNAME[0]} SOK"
          set_hana_attribute "$remoteNode" "SOK" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
          super_ocf_log info "ACT site=$sr_name, setting SOK for secondary (1)"
          lpa_set_lpt 30 "$remoteNode"
          rc=0;
       else
          # ok we should be careful and set secondary to SFAIL
          super_ocf_log info "FLOW ${FUNCNAME[0]} SFAIL"
          set_hana_attribute "$remoteNode" "SFAIL" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
          super_ocf_log info "ACT site=$sr_name, setting SFAIL for secondary (6) - srRc=$srRc lss=$lss No ACTIVES found in cmd output"
          # TODO: PRIO1 - P004: need to check LSS again to avoid dying primary to block (SFAIL) secondary
          lpa_set_lpt 10 "$remoteNode"
       fi
    elif [ $srRc -le 11 ]; then # 11 and 10
       # if systemReplicationStatus is ERROR and landscapeHostConfiguration is down then do NOT set SFAIL
       get_hana_landscape_status; lss=$?
       if [ $lss -lt 2 ]; then
          # keep everything like it was
          rc=2
       else
          # ok we should be careful and set secondary to SFAIL
          super_ocf_log info "FLOW ${FUNCNAME[0]} SFAIL"
          set_hana_attribute "$remoteNode" "SFAIL" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
          super_ocf_log info "ACT site=$sr_name, setting SFAIL for secondary (5) - srRc=$srRc lss=$lss"
          # TODO: PRIO1 - P004: need to check LSS again to avoid dying primary to block (SFAIL) secondary
          lpa_set_lpt 10 "$remoteNode"
          rc=1
       fi
    else
       super_ocf_log info "FLOW ${FUNCNAME[0]} SFAIL"
       set_hana_attribute "$remoteNode" "SFAIL" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
       super_ocf_log info "ACT site=$sr_name, setting SFAIL for secondary (2) - srRc=$srRc"
       # TODO: PRIO1 - P004: need to check LSS again to avoid dying primary to block (SFAIL) secondary
       lpa_set_lpt 10 "$remoteNode"
       rc=1;
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} PRIM+LPA"
    super_ocf_log info "DBG PRIM"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
####
#### OLD HDBSQL STUFF FOR SPS6,7,8 AND SCALE-UP ONLY
####
# function: analyze_hana_sync_statusSQL - query and check hana system replication status
# params:   -
# globals:  DIR_EXECUTABLE(r), remoteHost(r)
# get the HANA sync status
#
function analyze_hana_sync_statusSQL()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local -a clusterNodes=()
    local cl=""
    local vHost=""
    local n=""
    local hana_sync_status="" what_does_the_chamelion_say=""
    local secUser="SLEHALOC"
    local chkusr;
    local rc=0
    local sqlrc=0
# local query_state='select distinct REPLICATION_STATUS from SYS.M_SERVICE_REPLICATION'
# select distinct REPLICATION_STATUS from SYS.M_SERVICE_REPLICATION where SITE_NAME='"SITE1"'"
    local query_state="select distinct REPLICATION_STATUS from SYS.M_SERVICE_REPLICATION where SITE_NAME='"${sr_name}"'"
    local query_secondaries='select distinct  SECONDARY_HOST from SYS.M_SERVICE_REPLICATION'
    local query_failed_secondaries="select distinct SECONDARY_HOST from SYS.M_SERVICE_REPLICATION  where SECONDARY_SITE_NAME = (select distinct  SECONDARY_SITE_NAME from SYS.M_SERVICE_REPLICATION WHERE REPLICATION_STATUS != 'ACTIVE')"
    local all_cluster_hosts all_secondary_hosts all_broken_secondaries
#
#####################################################################################################
#
# select distinct SITE_NAME, HOST, REPLICATION_STATUS, SECONDARY_SITE_NAME, SECONDARY_HOST from SYS.M_SERVICE_REPLICATION
#
# ===> "Walldorf", "sap-app-8"  "ACTIVE", "Rot",  "sap-app-5"
#      "Rot",      "sap-app-5", "ACTIVE", "oslo", "sap-app-7"
#
#####################################################################################################
#
    secUser=$(check_secstore_users SAPHANA${SID}SR SLEHALOC RHELHALOC) ; chkusr=$?
    if [ $chkusr -ne 0 ]; then
        super_ocf_log err  "ACT: Secure store users are missing (see best practice manual how to setup the users)"
        rc=$OCF_ERR_CONFIGURED
    fi
    hana_sync_status=$(timeout $hdbSrQueryTimeout $DIR_EXECUTABLE/hdbsql -a -x -U $secUser  $query_state); sqlrc=$?
    hana_sync_status=$(echo $hana_sync_status | dequote)
    super_ocf_log debug "DBG: hdbsql rc=$sqlrc hana_sync_status=\"$hana_sync_status\""
    if [ "$sqlrc" -eq 0 -a "$hana_sync_status" != "" ]; then
        #
        # UNKNOWN, ACTIVE, ERROR, INITIALIZING
        #
        if [ "${hana_sync_status}" == "ACTIVE" ]; then
            # TODO PRIO1: REMOVE remoteNode dependency - set SOK
            set_hana_attribute "$remoteNode" "SOK" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
        else
            super_ocf_log warn "ACT: HANA SYNC STATUS is: ${hana_sync_status}"
            # TODO PRIO1: REMOVE remoteNode dependency - set SFAIL
            set_hana_attribute "$remoteNode" "SFAIL" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
        fi
    else
        case "$sqlrc" in
            19 )
                # return codes 19: license error -> set SFAIL!
                # DONE: PRIO1: We should NOT set SFAIL, if HDB is exactly broken now
                #       When HDB breaks during monitor this could prevent a prositive remote failover
                super_ocf_log warn "ACT: Was not able to fetch HANA SYNC STATUS - set sync status to SFAIL for ALL OTHER cluster hosts"
                for n in $otherNodes; do
                    set_hana_attribute "$n" "SFAIL" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
                done
                ;;
        esac
    fi
    return $rc
}

#
# function: get_hana_landscape_status - figure out hana landscape status
# params:   -
# globals:  sidadm(r), DIR_EXECUTABLE(r)
#
function get_hana_landscape_status()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    #
    # TODO: Get rid of the su by using a new interface:
    # SAPSYSTEMNAME=SLE /usr/sap/SLE/HDB00/HDBSettings.sh landscapeHostConfiguration.py
    # TODO: Check beginning from which SPS does SAP support HDBSettings.sh?
    # DONE: Limit the runtime of landscapeHostConfiguration.py
    HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "python landscapeHostConfiguration.py" 1>/dev/null 2>/dev/null; rc=$?
    if [ $rc -eq 124 ]; then
        # TODO: PRIO 1: Check, if we should loop here like 'for i in 1 2 3 ...' ?
        # landscape timeout
        super_ocf_log warn "RA: landscapeHostConfiguration.py TIMEOUT after $HANA_CALL_TIMEOUT seconds"
        sleep 20
        HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "python landscapeHostConfiguration.py" 1>/dev/null 2>/dev/null; rc=$?
        if [ $rc -eq 124 ]; then
           super_ocf_log warn "RA: landscapeHostConfiguration.py second TIMEOUT after $HANA_CALL_TIMEOUT seconds"
           # TODO PRIO2: How to handle still hanging lss - current solution is to say "FATAL"
           rc=0
        fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc;
}

#
# function: register_hana_secondary - register local hana as secondary to the other site
# params:   -
# globals:  sidadm(r), remoteHost(r), InstanceNr(r), sr_mode(r), sr_name(r), hdbver(r)
# register_hana_secondary
#
function register_hana_secondary()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=2;
    local remoteInstance="";
    local newParameter=0
    remoteInstance=$InstanceNr


    if version "$hdbver" ">=" "1.00.110"; then
        newParameter=1
    fi

    if ocf_is_true ${AUTOMATED_REGISTER}; then
       # TODO: Get rid of the su by using a new interface:
       # SAPSYSTEMNAME=SLE /usr/sap/SLE/HDB00/HDBSettings.sh hdbnsutil -sr_register ...
       # TODO: Check beginning from which SPS does SAP support HDBSettings.sh?
       # TODO: Limit the runtime of hdbnsutil -sr_register ????
       if [ $newParameter -eq 1 ]; then
           local hanaOM=""
           hanaOM=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_OPERATION_MODE[@]}")
           if [ -n "$hanaOM" ]; then
               hanaOM="--operationMode=$hanaOM"
           fi
           super_ocf_log info "ACT: REGISTER: hdbnsutil -sr_register --remoteHost=$remoteHost --remoteInstance=$remoteInstance --replicationMode=$sr_mode $hanaOM --name=$sr_name"
           set_hana_attribute "$NODENAME" "R" "${ATTR_NAME_HANA_SRACTION[@]}"
           set_hana_attribute "$NODENAME" "R" "${ATTR_NAME_HANA_SRACTION_HISTORY[@]}"
           HANA_CALL --timeout inf --use-su --cmd "hdbnsutil -sr_register --remoteHost=$remoteHost --remoteInstance=$remoteInstance --replicationMode=$sr_mode $hanaOM --name=$sr_name"; rc=$?
           set_hana_attribute "$NODENAME" "-" "${ATTR_NAME_HANA_SRACTION[@]}"
       else
           super_ocf_log info "ACT: REGISTER: hdbnsutil -sr_register --remoteHost=$remoteHost --remoteInstance=$remoteInstance --mode=$sr_mode --name=$sr_name"
           set_hana_attribute "$NODENAME" "R" "${ATTR_NAME_HANA_SRACTION[@]}"
           set_hana_attribute "$NODENAME" "R" "${ATTR_NAME_HANA_SRACTION_HISTORY[@]}"
           HANA_CALL --timeout inf --use-su --cmd "hdbnsutil -sr_register --remoteHost=$remoteHost --remoteInstance=$remoteInstance --mode=$sr_mode --name=$sr_name"; rc=$?
           set_hana_attribute "$NODENAME" "-" "${ATTR_NAME_HANA_SRACTION[@]}"
       fi
       # backup_global_and_nameserver
    else
       super_ocf_log info "ACT: SAPHANA DROP REGISTER because AUTOMATED_REGISTER is set to FALSE"
       rc=1
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc;
}

#
# function: saphana_status - pure status check
# params:   -
# globals:  SIDInstanceName, OCF_*,
function saphana_status() {
    local binDeam="hdb.sap${SIDInstanceName}" rc=0
    binDeam=${binDeam:0:15}   # Process name is limited to the first 15 characters
    if pgrep $binDeam 1>/dev/null; then rc=$OCF_SUCCESS; else rc=$OCF_NOT_RUNNING; fi
    return $rc
}

#
# function: saphana_start - start a hana instance
# params:   -
# globals:  OCF_*, SAPCONTROL, InstanceNr, SID, InstanceName,
#
function saphana_start() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=$OCF_NOT_RUNNING
    local output=""
    local loopcount=0
    local lastSrHook
    check_sapstartsrv
    rc=$?
    #
    # DONE: ASK: PRIO5: For SCALE-OUT - do we need to use another call like StartSystem? Or better to use the HDB command?
    #
    if [ $rc -eq $OCF_SUCCESS ]; then
        lastSrHook=$(get_SRHOOK_plain "$sr_name")
        if [ -n "$lastSrHook" ]; then
            # reset old srHook attribute to SWAIT as we are starting right now
            set_SRHOOK "$sr_name" "SWAIT"
        fi
        output=$($SAPCONTROL -nr $InstanceNr -function Start)
        rc=$?
        super_ocf_log info "ACT: Starting SAPHANA Instance $SID-$InstanceName: $output"
    fi
    if [ $rc -eq 0 ]
    then
        HANA_ACTION_TIMEOUT=$(get_action_timeout)
        output=$($SAPCONTROL -nr $InstanceNr -function WaitforStarted $HANA_ACTION_TIMEOUT 1)
        if [ $? -eq 0 ]
        then
            super_ocf_log info "ACT: SAPHANA Instance $SID-$InstanceName started: $output"
            rc=$OCF_SUCCESS
        else
            super_ocf_log err "ACT: SAP HANA: Instance $SID-$InstanceName start failed: $output"
            rc=$OCF_ERR_GENERIC
        fi
    else
        super_ocf_log err "ACT: SAPHANA Instance $SID-$InstanceName start failed: $output"
        rc=$OCF_ERR_GENERIC
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_stop - stop a hana instance
# params:   -
# globals:  OCF_*(r), SAPCONTROL(r), SID(r), InstanceName(r)
# saphana_stop: Stop the SAP instance
#
function saphana_stop() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local output=""
    local rc=0
    check_sapstartsrv; rc=$?
    if [ $rc -eq $OCF_SUCCESS ]; then
    output=$($SAPCONTROL -nr $InstanceNr -function Stop)
    rc=$?
    super_ocf_log info "ACT: Stopping SAP Instance $SID-$InstanceName: $output"
  fi
  if [ $rc -eq 0 ]
  then
    HANA_ACTION_TIMEOUT=$(get_action_timeout)
    output=$($SAPCONTROL -nr $InstanceNr -function WaitforStopped $HANA_ACTION_TIMEOUT 1)
    if [ $? -eq 0 ]
    then
      super_ocf_log info "ACT: SAP Instance $SID-$InstanceName stopped: $output"
      rc=$OCF_SUCCESS
    else
      super_ocf_log err "ACT: SAP Instance $SID-$InstanceName stop failed: $output"
      rc=$OCF_ERR_GENERIC
    fi
  else
    super_ocf_log err "ACT: SAP Instance $SID-$InstanceName stop failed: $output"
    rc=$OCF_ERR_GENERIC
  fi
  super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
  return $rc
}

#
# function: saphana_validate - validation of (some) variables/parameters
# params:   -
# globals:  OCF_*(r), SID(r), InstanceName(r), InstanceNr(r), SAPVIRHOST(r)
# saphana_validate: Check the semantic of the input parameters
#
function saphana_validate() {
  super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
  local rc=$OCF_SUCCESS
  #
  # SID is Alpha-AlphaNumeric-Alphanumeric?
  #
  if [[ ! "$SID" =~ ^[A-Z][A-Z0-9][A-Z0-9]$ ]]
  then
    super_ocf_log err "ACT: Parsing instance profile name: '$SID' is not a valid SID!"
    rc=$OCF_ERR_ARGS
  fi
  #
  # InstanceNr is a two-Digit?
  #
  if [[ ! "$InstanceNr" =~ ^[0-9][0-9]$ ]]
  then
    super_ocf_log err "ACT: Parsing instance profile name: '$InstanceNr' is not a valid instance number!"
    rc=$OCF_ERR_ARGS
  fi
  super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
  return $rc
}

#
# function: saphana_start_primary - handle startup of PRIMARY in M/S
# params:
# globals: OCF_*(r), NODENAME, ATTR_NAME_*, HANA_STATE_*,
#
function saphana_start_primary()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local primary_status sync_attr score_master rc=$OCF_NOT_RUNNING
    local lss sqlrc;
    local rc=0
    local lpa_dec=4
    local lpa_advice=""
    #
    # we will be a master (PRIMARY) so checking, if the is anOTHER master
    #
    super_ocf_log debug "DBG: saphana_primary - check_for_primary reports HANA_STATE_PRIMARY"
    #
    lpa_init_lpt $HANA_STATE_PRIMARY
    lpa_check_lpt_status; lpa_dec=$?
    get_hana_landscape_status; lss=$?
    my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
    my_sync=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_SYNC_STATUS[@]}")
    case "$lpa_dec" in
        0 ) # LPA says start-up
            lpa_advice="start"
            # TODO: PRIO1: We need to do a special handling for remote being a 234-Secondary in SR Status SOK
            # if ( remote_role like [234]:S )  && ( remote_sync_status is SOK|PRIM ) && ( PreferSiteTakeover )
            #   then lpa_advice="wait"
            remoteRole=$(get_hana_attribute "$remoteNode" "${ATTR_NAME_HANA_ROLES[@]}")
            remoteSync=$(get_SRHOOK "$remSR_name" "$remoteNode")
            super_ocf_log info "DEC: saphana_primary - checking remoteStatus"
            if ocf_is_true "${PreferSiteTakeover}"; then
                remoteStatus="$remoteRole:$remoteSync"
                case "$remoteStatus" in
                    [234]:S:*:SOK | [234]:S:*:PRIM )
                        lpa_advice="wait"
                        # TODO: PRIO3: Split WAIT into WAIT4TAKEOVER
                        super_ocf_log info "DEC: saphana_primary - waiting for secondary to takeover (SOK, PreferSiteTakover)"
                    ;;
                    * )
                        super_ocf_log info "DEC: saphana_primary - remoteStatus is: $remoteStatus"
                        ;;
                esac
            else
                super_ocf_log info "DEC: saphana_primary - PreferSiteTakeover set to false"
            fi
            ;;
        1)  # LPA says register!
            lpa_advice="register"
            ;;
        2)  # LPA says wait for older LPA to expire
            lpa_advice="wait"
            ;;
        3) # LPA says to wait for remote LPA to be reported/announced
            lpa_advice="wait"
            ;;
        4) # LPA says something is completely wrong - FAIL resource # TODO: PRIO1: RC3 for waiting remote side to report lss
            lpa_advice="fail"
            ;;
        *) # LPA failed with an unknown status - FAIL resource
            lpa_advice="fail"
            ;;
    esac

    # DONE: PRIO2: Do we need to differ 0 and 1 here? While 0 is a fatal SAP error, 1 for down/error
    if [ $lss -eq 0 ]; then
       super_ocf_log err "ACT: get_hana_landscape_status reports FATAL"
       # DONE: PRIO1: what to do for lss=0?
       # TODO: PRIO3: Check, if OCF_ERR_GENERIC is best reaction
       lpa_advice="skip"
       rc=$OCF_ERR_GENERIC
    fi

    my_sync=$(get_SRHOOK "$sr_name" "$NODENAME")
    case "$lpa_advice" in
        start )  # process a normal START
            case "$lss" in
                2 | 3 | 4 ) # as landscape says we are up - just set the scores and return code
                    super_ocf_log info "LPA: landscape: UP, LPA: start ==> keep running"
                    LPTloc=$(date '+%s')
                    lpa_set_lpt $LPTloc "$NODENAME"
                    rc=$OCF_SUCCESS
                    ;;
                1 ) # landscape says we are down, lets start and adjust scores and return code
                    super_ocf_log info "LPA: landscape: DOWN, LPA: start ==> start instance"
                    saphana_start
                    rc=$?
                    LPTloc=$(date '+%s')
                    lpa_set_lpt $LPTloc "$NODENAME"
                    ;;
            esac
            if [ -z "$my_role" ]; then
                my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
            fi
            super_ocf_log info "DEC: saphana_start_primary: scoring_crm_master($my_role,$my_sync)"
            scoring_crm_master "$my_role" "$my_sync"
            ;;
        register ) # process a REGISTER
            case "$lss" in
                2 | 3 | 4 ) # upps we are up - but shouldn't? - we could not register with started HDB
                    # DONE: PRIO3: check if this reaction is correct - tell cluster about failed start
                    super_ocf_log info "LPA: landscape: UP, LPA: register ==> take down"
                    set_crm_master -inf
                    rc=$OCF_NOT_RUNNING
                    ;;
                1 ) # lets try to register
                    # DONE: PRIO2: Like Action in start_secondary
                    super_ocf_log info "LPA: landscape: DOWN, LPA: register ==> try to register"
                    super_ocf_log info "DEC: ANOTHER HANA IS AVAILABLE ==> LETS REGISTER"
                    set_crm_master  0
                    if wait_for_primary_master 1; then
                        register_hana_secondary
                        check_for_primary; primary_status=$?
                        if [ $primary_status -eq $HANA_STATE_SECONDARY ]; then
                            super_ocf_log info "ACT: Register successful"
                            lpa_push_lpt 10
                            lpa_set_lpt  10 "$NODENAME"
                            set_crm_master  0
                            saphana_start_secondary
                            rc=$?
                            lpa_set_lpt  10 "$NODENAME"
                        else
                            super_ocf_log err "ACT: Register failed. Expected:'$HANA_STATE_SECONDARY' Actual: '$primary_status'"
                            rc=$OCF_NOT_RUNNING
                        fi
                    else
                        # lets check next monitor, if we can register
                        rc=$OCF_SUCCESS
                    fi
                    ;;
            esac
            ;;
        wait )  # process a WAIT
            case "$lss" in
                2 | 3 | 4 ) # as we ARE up we just keep it up
                    # TODO: PRIO3: I now change from "just keep it up to take that down"
# TODO: PRIO1 differ lpt_advice!!
# 2 => DOWN
# 3 => KEEP
                    # TODO: PRIO3: OCF_SUCCESS, OCF_NOT_RUNNING or OCF_ERR_xxxx ?
                    set_crm_master -9000
                    #scoring_crm_master "$my_role" "$my_sync"
                    rc="$OCF_ERR_GENERIC"
                    ;;
                1 ) # we are down, so we should wait --> followup in next monitor
                    # DONE: PRIO3: Check, if WAITING is correct here
                    if ocf_is_true "$AUTOMATED_REGISTER" ; then
                        super_ocf_log info "LPA: landscape: DOWN, LPA: wait ==> keep waiting"
                        super_ocf_log info "RA: landscape: DOWN, LPA: wait ==> keep waiting"
                        set_hana_attribute "${NODENAME}" "WAITING4LPA" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
                        set_crm_master -9000
                        rc="$OCF_SUCCESS"
                    else
                        super_ocf_log warn "LPA: OLD primary needs manual registration (AUTOMATED_REGISTER='false')"
                        set_hana_attribute "${NODENAME}" "WAITING4REG" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
                        set_crm_master -9000
                        rc="$OCF_NOT_RUNNING"
                    fi
                    ;;
            esac
            ;;
        fail )   # process a lpa FAIL
            super_ocf_log info "LPA: LPA reports FAIL"
            set_crm_master -inf
            rc="$OCF_NOT_RUNNING"
            ;;
    esac
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# check_for_primary_master
# params: -
# globals: ATTR_NAME_HANA_ROLES[@], NODENAME
#
check_for_primary_master()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local ch ch_role
    #
    # get actual list of cluster members
    #
    if [ -n "$otherNodes" ]; then
        for ch in ${otherNodes[@]}; do
            if [ $rc -eq 1 ]; then
                ch_role=$(get_hana_attribute "${ch}" "${ATTR_NAME_HANA_ROLES[@]}")
                # TODO: PRIO3: check if [0-9], [234] or [34] is correct
                # TODO: PRIO4: Do we need different checks like "any-primary-master" or "running-primary-master" ?
                #                grep '[0-9]*:P:[^:]*:master:' <<< $ch_role && rc=0
                #                grep '[34]:P:[^:]*:master:' <<< $ch_role && rc=0
                #               Match "Running+Available Primary" Master -> Match field 1: 3/4, 2: P, 4: master
                super_ocf_log debug "DBG: check_for_primary_master (3) ch_role=$ch_role"
                awk -F: 'BEGIN { rc=1 }
                         $1 ~ "[34]" && $2 == "P" && $4 == "master" { rc=0 }
                         END { exit rc }' < <(echo $ch_role) ; rc=$?
                super_ocf_log debug "DBG: check_for_primary_master (4) rc=$rc"
            fi
        done
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# wait_for_primary_master: wait some time till a running primary master is shown in attributes
# params: optional: loop count - currently time in 10s waiting loop
# globals: -
#
wait_for_primary_master()
{
    local wait=1
    local rc=1
    local loops=${1:-0}
    local count=0
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    #
    # hana_ndb_roles=primary:master1:master:worker:master
    #
    while [ "$wait" -eq 1 ]; do
        if check_for_primary_master; then
           wait=0
           rc=0
        else
           if [ $loops -gt 0 ]; then
              (( count++ ))
              if [ $count -gt $loops ]; then
                 wait=0
                 rc=1
              fi
           fi
           sleep 10
        fi
    done
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_start_secondary - handle startup of PRIMARY in M/S
# params:
# globals: OCF_*(r), NODENAME, ATTR_NAME_*,
#
function saphana_start_secondary()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local primary_status sync_attr score_master rc=$OCF_NOT_RUNNING
    local sqlrc;
    set_crm_master 0
    #
    ####### LPA - begin
    #
    lpa_push_lpt 10
    lpa_set_lpt  10 "$NODENAME"
    #
    ####### LPA - end
    #
    #
    # we would be secondary
    # we first need to check, if there are Master Nodes, because the Secondary only starts
    # successfully, if the Primary is available. Therefor we mark the Secondary as "WAITING"
    # DONE: PRIO3: wait_for_primary_master 10 is just a test value: 10 loops x10 seconds, then go to WAITING
    # DONE: PRIO3: rename 'wait_for_primary_master' to match better the use case ("wait_some_time")
    #
    super_ocf_log debug "DBG: wait for promoted side"
    # TODO: PRIO3: Check if setting SFAIL during secondary start is ok
    set_hana_attribute "${NODENAME}" "SFAIL" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
    if wait_for_primary_master 10; then
       saphana_start; rc=$?
       if [ $rc -ne $OCF_SUCCESS ]; then
           if ! wait_for_primary_master 1; then
               # It seems the stating secondary could not start because of stopping primary
               #    so this is a WAITING situation
               super_ocf_log info "ACT: PRIMARY seems to be down now ==> WAITING"
               set_hana_attribute "${NODENAME}" "WAITING4PRIM" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
               set_crm_master -INFINITY
               rc=$OCF_SUCCESS
           fi
       else
           lpa_set_lpt  10 "$NODENAME"
       fi
    else
       super_ocf_log info "ACT: wait_for_primary_master ==> WAITING"
       set_hana_attribute "${NODENAME}" "WAITING4PRIM" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
       set_crm_master -INFINITY
       rc=$OCF_SUCCESS
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_check_local_instance
# params:
# output:
# rc:       rc=0 (UP) rc=1 (DOWN)
# globals:
#
function saphana_check_local_instance()
{
    local rc=1
    local count=0
    local SERVNO
    local output
    local MONITOR_SERVICES="hdbnameserver|hdbdaemon" # TODO: PRIO1: exact list of Services
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    check_sapstartsrv
    rc=$?
    if [ $rc -eq $OCF_SUCCESS ]
    then
      output=$($SAPCONTROL -nr $InstanceNr -function GetProcessList -format script)
      # we have to parse the output, because the return code doesn't tell anything about the instance status
      for SERVNO in `echo "$output" | grep '^[0-9] ' | cut -d' ' -f1 | sort -u`
      do
        local COLOR=`echo "$output" | grep "^$SERVNO dispstatus: " | cut -d' ' -f3`
        local SERVICE=`echo "$output" | grep "^$SERVNO name: " | cut -d' ' -f3`
        local STATE=0
        local SEARCH

        case $COLOR in
          GREEN|YELLOW)       STATE=$OCF_SUCCESS;;
          *)                  STATE=$OCF_NOT_RUNNING;;
        esac

        SEARCH=`echo "$MONITOR_SERVICES" | sed 's/\+/\\\+/g' | sed 's/\./\\\./g'`
        if [ `echo "$SERVICE" | egrep -c "$SEARCH"` -eq 1 ]
        then
          if [ $STATE -eq $OCF_NOT_RUNNING ]
          then
            [ "$MONLOG" != "NOLOG" ] && ocf_log err "SAP instance service $SERVICE status color is $COLOR !"
            rc=$STATE
          fi
          count=1
        fi
      done

      if [ $count -eq 0 -a $rc -eq $OCF_SUCCESS ]
      then
        if ocf_is_probe
        then
          rc=1
        else
          [ "$MONLOG" != "NOLOG" ] && ocf_log err "The SAP instance does not run any services which this RA could monitor!"
          rc=1
        fi
      fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: lpa_get_lpt - get lpt from cluster
# params:   NODE
# output:   LPT
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
# globals:  LPA_ATTR_*,
#
function lpa_get_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local node=$1
    local lpt=""
    lpt=$(get_hana_attribute ${node} ${LPA_ATTR[@]})
    if [ -n "$lpt" ]; then
        rc=0
        echo $lpt
    else
        rc=2
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: lpa_set_lpt - set lpt in cluster
# params:   LPT [node]
# globals:  LPA_ATTR(r), NODENAME(r),
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
#
function lpa_set_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local crm_rc=1
    local lpt=$1
    local clpt=-1
    local node=$2
    set_hana_attribute ${node} "$lpt" ${LPA_ATTR[@]}; crm_rc=$?
    if [ -n "$node" ]; then
        clpt=$(lpa_get_lpt "$NODENAME")
        if [ "$lpt" != "$clpt" ]; then
            rc=2
        else
            rc=0
        fi
    else
       super_ocf_log info "DEC: lpa_set_lpt - ignore to change value for empty node name"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: lpa_pull_lpt - fetch lpt from file
# params:   -
# globals:  LPA_DIRECTORY(r), sid, NODENAME
# output:   LPT
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
#
function lpa_pull_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local lpt=""
    local readrest=0
    local lpa_file="$LPA_DIRECTORY/lpa_${sid}_${NODENAME}"
    if [ -f $lpa_file ]; then
        read lpt readrest < <(cat $lpa_file) # exactly load first word from file to lpt
    fi
    if [ -n "$lpt" ]; then
        rc=0
        echo $lpt
    else
        rc=2
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: lpa_push_lpt - put lpt to file
# params:   LPT
# globals:  LPA_DIRECTORY(r), sid, NODENAME
# output:   --
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
#
function lpa_push_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local lpt=$1
    local clpt=-1
    local rc=1
    local lpa_file="$LPA_DIRECTORY/lpa_${sid}_${NODENAME}"
    #
    mkdir -p "$LPA_DIRECTORY"
    echo "$lpt" > $lpa_file
    clpt=$(lpa_pull_lpt); lpt_rc=$?
    if [ "$clpt" != "$lpt" -o "$lpt_rc" -ne 0 ]; then
        rc=2
    else
        rc=0
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: lpa_init_lpt - initialize local lpt, if needed
# params:   HANA_STATE
# globals:  HANA_STATE_*(r), LPA_DIRECTORY(r), sid(r), NODENAME(r),
# lpa_init_lpt
#
# Returncodes:
#    rc=0: OK,  rc=1 InternalERROR,  rc=2: ERROR
#
# Initializing (if NO local LPT-file):
#    SECONDARY sets to 0
#    PRIMARY   sets to 1
#
function lpa_init_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local LPTloc=-1
    local LPTrem=-1
    local hana_state=$1
    local lpa_file="$LPA_DIRECTORY/lpa_${sid}_${NODENAME}"
    mkdir -p $LPA_DIRECTORY
    LPTloc=$(lpa_get_lpt "${NODENAME}") || LPTloc=$(lpa_pull_lpt) || \
        if   [ "$hana_state" -eq "$HANA_STATE_PRIMARY" ];  then    # Initialize for Primary
            # init primary
            LPTloc=20
            lpa_push_lpt "20"; rc=$?
        elif [ "$hana_state" -eq "$HANA_STATE_SECONDARY" ]; then   # Initialize for Secondary
            # init secondary
            LPTloc=10
            lpa_push_lpt "10"; rc=$?
        else
            rc=2
        fi
    lpa_set_lpt $LPTloc "$NODENAME"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: lpa_check_lpt_status - start a hana clone instance
# params:   -
# globals:  DUPLICATE_PRIMARY_TIMEOUT, NODENAME, remoteNode
# lpa_check_lpt_status
#
# Returncodes:
#    0: start
#    1: register    (then start)
#    2: wait4gab    (WAIT4LPA - Older LPA needs to expire)
#    3: wait4other  (WAIT4LPA - Remote LPA needs to be announced)
#    4: lpa internal error
#
# Initializing (if NO local LPT-file):
#    SECONDARY sets to 10
#    PRIMARY   sets to 20
#
#    LPRlocal OR LPTremore ARE real lpt (>1000)
#        THEN:
#            Bigger LPR wins, if delta-gab is OK
#               LPTlocal >> LPTremore ===> rc=0 (start)
#               LPTRemote >> LPTlocal ===> rc=1 (register)
#            Stalemate in all other cases ==> STALEMATE-HANDLING ===> rc=2 (wait4gab)
#    LPRlocal AND LPTremore ARE NOT real lpt (<=1000)
#        THEN:
#            Bigger LPT wins
#               LPTlocal > LPTremore ===> rc=0 (start)
#               LPTRemote > LPTlocal ===> rc=1 (register)
#            Stalemate in all other cases ==> STALEMATE-HANDLING ===> rc=2 (wait4gab)
#    LPTRemote is not initialized or node not kown in cluster (crm_mon -l) (0)
#    TODO: PRIO1: Need to introduce a return-code 3 for remote sides lpa not ready
#        THEN:
#            WAIT ==> like STALEMATE-HANDLING ===> rc=2 (wait)
#
function lpa_check_lpt_status() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=4
    local LPTloc=-1
    local LPTrem=-1
    local LPTMark=1000
    local delta=0
    local remSn_name=""
    local remHost=""
    #
    # First GET LPT from ATTR-FILE-DEFAULT
    #
    LPTloc=$(lpa_get_lpt "$NODENAME"); lparc=$?   # ATTR
    if [ "$lparc" -ne 0 ]; then
        # as a fallback try to fetch the value from external status file
        LPTloc=$(lpa_pull_lpt);                 # FILE
        lparc=$?
        if [ -z "$LPTloc" -o "$LPTloc" -eq -1 -o "$lparc" -ne 0 ]; then
            # last option - try to initialize as PRIMARY
            lpa_push_lpt 20
            lpa_set_lpt  20 "$NODENAME"
            LPTloc=20                           # DEFAULT
        fi
    fi
    # TODO PRIO1: REMOVE remoteNode dependency - lpa_get_lpt
    LPTrem=$(lpa_get_lpt $remoteNode); lparc=$?
    if [ $lparc -ne 0 ]; then
        # LPT of the other node could not be evaluated - LPA says WAIT
        super_ocf_log debug "DBG: LPA: LPTloc=$LPTloc, LPTrem undefined ==> WAIT"
        rc=3
    else
        super_ocf_log debug "DBG: LPA: LPTloc ($LPTloc) LPTrem ($LPTrem) delta ($delta)"
        if [ $LPTloc -lt $LPTMark -a $LPTrem -lt $LPTMark ]; then
           delta=0   # both lpts are not a real timestamp so just take the greater one
        else
           delta=$DUPLICATE_PRIMARY_TIMEOUT   # at least one of the lpts is a real timestamp so include delta-gap
        fi
        if (( delta < LPTloc - LPTrem )); then
            # We are the winner - LPA says STARTUP
            super_ocf_log debug "DBG: LPA: LPTloc wins $LPTloc > $LPTrem + $delta ==> START"
            rc=0
        elif (( delta < LPTrem - LPTloc )); then
            if ocf_is_true "$AUTOMATED_REGISTER" ; then
                # The other one has won - LPA says REGISTER
                super_ocf_log debug "DBG: LPA: LPTrem wins $LPTrem > $LPTloc + $delta ==> REGISTER"
                rc=1
            else
                super_ocf_log debug "DBG: LPA: LPTrem wins $LPTrem > $LPTloc + $delta BUT AUTOMATED_REGISTER='false' ==> WAIT"
                rc=2
            fi

        else
            super_ocf_log debug "DBG: LPA: Difference between LPTloc and LPTrem is less than delta ($delta) ==> WAIT"
            # TODO: PRIO3: ADD STALEMATE-HANDLING HERE; currently admin should set one of the lpa to 20
            rc=2
        fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

# function: is_the_master_nameserver
# params:   -
# rc:       0: yes, local node is THE master nameserver
#           1: else
# globals:
function is_the_master_nameserver()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    # always true for scale-up
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_start_clone - start a hana clone instance
# params:   -
# globals:  OCF_*, ATTR_NAME_*, HANA_STATE_*, NODENAME
# saphana_start_clone
#
function saphana_start_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local primary_status sync_attr score_master rc=$OCF_NOT_RUNNING
    local sqlrc;
    set_hana_attribute "${NODENAME}" "DEMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
    check_for_primary; primary_status=$?
    if [ $primary_status -eq $HANA_STATE_PRIMARY ]; then
        saphana_start_primary; rc=$?
    elif [ $primary_status -eq $HANA_STATE_SECONDARY ]; then
        lpa_set_lpt  10 $NODENAME
        saphana_start_secondary; rc=$?
    else
        super_ocf_log error "SAP HANA is neither PRIMARY nor SECONDARY cant start this SAP HANA database for SR control."
        rc="$OCF_NOT_RUNNING"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_stop_clone - stop a hana clone instance
# params:   -
# globals:  NODENAME(r), HANA_STATE_*(r)
# saphana_stop_clone
#
function saphana_stop_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local primary_status="x"
    set_hana_attribute "${NODENAME}" "UNDEFINED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
    super_ocf_log debug "DBG: SET UNDEFINED"
    check_for_primary; primary_status="$?"
    if [ "$primary_status" -eq "$HANA_STATE_SECONDARY" ]; then
        lpa_set_lpt  10 "$NODENAME"
    fi
    saphana_stop; rc="$?"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

function recover_site_attributes_from_file()
{
    local srHookAttributeFile="$1"
    local site

    if [ -f "$srHookAttributeFile" ]; then
        #
        # need to read attribute from the file
        #
        # TODO: PRIO0: also allow a=b instead of a = b
        # TODO: PRIO5: also allow multiple attributes each in an own line - for now only one attribute is needed
        read srATTR EQS srVALUE <"$srHookAttributeFile"
        case "$srATTR" in
            hana_${sid}_site_srHook_* )
                #
                # get site name from site attribute-name
                #
                site="${srATTR#hana_${sid}_site_srHook_}"
                super_ocf_log info "DEC: srHookAttribute file found - recover lost SAP HA/DR event ($srATTR=$srVALUE)"
                #
                # DONE: PRIO0 - add check for srATTR name here
                #
                case "$srVALUE" in
                SOK )
                      super_ocf_log info "DEC: recover attributes from file $srHookAttributeFile - calling set_SRHOOK $site SOK"
                      set_SRHOOK "$site" "SOK"
                      ;;
                SFAIL )
                      super_ocf_log info "DEC: recover attributes from file $srHookAttributeFile - calling set_SRHOOK $site SFAIL"
                      set_SRHOOK "$site" "SFAIL"
                      ;;
                * )
                      super_ocf_log info "DEC: failed recover attributes from file $srHookAttributeFile - Unknown value <<$srVALUE>>"
                      ;;
                esac
                ;;
        esac
        rm "$srHookAttributeFile"
    fi
}

#
# function: saphana_monitor_primary - monitor a hana clone instance
# params:   -
# globals:  HANA_STATE_*(r), remoteHost, NODENAME, ATTR_NAME_*, OCF_*, PreferSiteTakeover
#
function saphana_monitor_primary()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=$OCF_ERR_GENERIC
    local promoted=0
    local init_attribute=0
    local LPTloc=-1
    local lparc=4
    local lss
    local remoreSync=""
    local my_role=""
    #
    # OK, we are running/are configured as HANA PRIMARY
    #
    super_ocf_log debug "DBG: saphana_monitor_clone: HANA_STATE_PRIMARY"
    #
    ##### CHECK, IF WE ARE DEMOTED (CLUSTER NODE ATTRIBUTE)
    #
    promote_attr=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_CLONE_STATE[@]}")
    super_ocf_log debug "DBG: saphana_monitor_clone: $ATTR_NAME_HANA_CLONE_STATE=$promote_attr"
    if [ -z "$promote_attr" ]; then
        init_attribute=1
        promoted=0;
    else
        case "$promote_attr" in
            PROMOTED )
                promoted=1;
                ;;
            DEMOTED )
                promoted=0;
                ;;
            WAITING* )
                # DONE: lpa_check_lpt_status to come out of here :)
                # DONE: PRIO2: CHECK IF THE FIX FOR COMING OUT OF WAITING IS CORRECT
                get_hana_landscape_status; lss=$?
                if [ $lss -ge 2 ]; then
                    # seems admin already decided that for us? -> we are running - set DEMOTED
                    promoted=0;
                    LPTloc=$(date '+%s')
                    lpa_set_lpt $LPTloc "$NODENAME"
                fi
                lpa_check_lpt_status; lparc=$?
                # DONE: PRIO1: Need to differ lpa_check_lpt_status return codes
                case "$lparc" in
                   0 | 1 )
                        # lpa - no need to wait any longer - lets try a new start
                        saphana_start_clone
                        rc=$?
                        super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
                        return $rc
                        ;;
                    2 )
                        lpa_init_lpt $HANA_STATE_PRIMARY
                        # still waiting for second site to expire
                        if ocf_is_true "$AUTOMATED_REGISTER" ; then
                           super_ocf_log info "LPA: Still waiting for remote site to report LPA status"
                        else
                           super_ocf_log info "LPA: Dual primary detected and AUTOMATED_REGISTER='false' ==> WAITING"
                           super_ocf_log info "LPA: You need to manually sr_register the older primary"
                        fi
                        return $OCF_SUCCESS
                    ;;
                    3 )
                        lpa_init_lpt $HANA_STATE_PRIMARY
                        # still waiting for second site to report lpa-lpt
                        super_ocf_log info "LPA: Still waiting for remote site to report LPA status"
                        return $OCF_SUCCESS
                    ;;
                    4 )
                        # lpa internal error
                        # TODO PRIO3: Implement special handling for this issue - should we fail the ressource?
                        super_ocf_log info "LPA: LPA reports an internal error"
                        return $OCF_SUCCESS
                    ;;
                esac
                promoted=0;
                ;;
            UNDEFINED )
                if ocf_is_probe; then
                   promoted=0;
                else
                   set_hana_attribute "${NODENAME}" "DEMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
                   promoted=0;
                fi
                ;;
            * )
                promoted=0;
                ;;
        esac
    fi
    get_hana_landscape_status; lss=$?
    super_ocf_log debug "DBG: saphana_monitor_clone: get_hana_landscape_status=$lss"
    case "$lss" in
        0 ) # FATAL or ERROR
            rc=$OCF_ERR_GENERIC
            ;;
        1 ) # DOWN or ERROR
            # DONE: PRIO2: Maybe we need to differ between 0 and 1. While 0 is a fatal sap error, 1 is down/error
            if ocf_is_probe; then
                #
                # leave master score untouched, only set return code
                #
                rc=$OCF_NOT_RUNNING
            else
                if [ "$promoted" -eq 1 ]; then
                    # INSTANCE IS FAILED PRIMARY IN PROMOTED STATE
                    # DONE: PRIO2: Adjust with set_crm_master?
                    #       For Migration it would be good to decrease master score
                    #       For Reload locally we should NOT adjust the master score
                    # ===>  Should we rely on the migration threshold?
                    #       set_crm_master
                    if ocf_is_true "${PreferSiteTakeover}" ; then
                        #
                        # DONE: PRIO1: first check, if remote site is already (and still) in sync
                        # TODO: PRIO4: Decide if penalty (-9000) or weak (5) is better here to cover situations where other clone is gone
                        #
                        # TODO PRIO1: REMOVE remoteNode dependency - get_sync_status
                        remoteSync=$(get_SRHOOK "$remSR_name" "$remoteNode")
                        # TODO HANDLING OF "NEVER"
                        case "$remoteSync" in
                            SOK | PRIM )
                                 super_ocf_log info "DEC: PreferSiteTakeover selected so decrease promotion score here (and reset lpa)"
                                 if check_for_primary_master; then
                                     lpa_set_lpt 20 "$NODENAME"
                                 fi
                                 #
                                 # DOWNSCORING CRM_MASTER TO DEMOTE THE PRIMARY MUST BE DONE AFTER THE LPT MARKING NO TO RISK CANCELLATION OF THE MONITOR
                                 #
                                 set_crm_master 5
                                 ;;
                            SFAIL )
                                 super_ocf_log info "DEC: PreferSiteTakeover selected BUT remote site is not in sync (SFAIL) ==> local restart preferred"
                                 ;;
                            * )
                                 super_ocf_log info "DEC: PreferSiteTakeover selected BUT remote site is not in sync ($remoteSync) ==> local restart preferred"
                                 ;;
                        esac
                    else
                        # TODO:  PRIO5: SCALE-OUT ONLY? Implement for local restart
                        #        It maybe that for the local restart we only need to decrease the secondaries promotion score
                        #super_ocf_log info "DEC: PreferSiteTakeover selected so decrease promotion score here"
                        my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
                        my_sync=$(get_SRHOOK "$sr_name" "$NODENAME")
                        super_ocf_log info "DEC: saphana_monitor_primary: scoring_crm_master($my_role,$my_sync)"
                        scoring_crm_master "$my_role" "$my_sync"
                        rc=$OCF_FAILED_MASTER
                    fi
                    rc=$OCF_FAILED_MASTER
                else
                    # INSTANCE IS FAILED PRIMARY IN DEMOTED STATE
                    # TODO: PRIO3: Adjust with set_crm_master?
                    #       Current decision: Do NOT adjust master score now as other
                    #       steps should already have done that
                    #
                    super_ocf_log info "DEC: PRIMDEFECT (in DEMOTED status)"
                    rc=$OCF_NOT_RUNNING
                fi
            fi
            ;;
        2 | 3 | 4 ) # WARN, INFO or OK
            if ocf_is_probe; then
                if [ "$promoted" -eq 1 ]; then
                    rc=$OCF_RUNNING_MASTER
                else
                    rc=$OCF_SUCCESS
                fi
                set_SRHOOK_PRIM
                my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
                super_ocf_log info "DEC: saphana_monitor_primary: scoring_crm_master($my_role,$my_sync)"
                scoring_crm_master "$my_role" "$my_sync"
            else
                LPTloc=$(date '+%s')
                lpa_set_lpt $LPTloc "$NODENAME"
                lpa_push_lpt $LPTloc
                if [ "$promoted" -eq 1 ]; then
                    set_hana_attribute "$NODENAME" "PRIM" "${ATTR_NAME_HANA_SYNC_STATUS[@]}"
                    rc=$OCF_RUNNING_MASTER
                else
                    if [ "$init_attribute" -eq 1 ]; then
                        set_hana_attribute "${NODENAME}" "DEMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
                        rc=$OCF_RUNNING_MASTER
                    else
                        rc=$OCF_SUCCESS
                    fi
                fi
                my_sync=$(get_SRHOOK "$sr_name" "$NODENAME")
                my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
                #
                # first check, if we have a pending HA/DR provider attribute in the interface files
                #
                recover_site_attributes_from_file "/hana/shared/$SID/$InstanceName/.crm_attribute.$remSR_name"
                #
                # second check, if we have a pending HA/DR provider attribute in the interface files of "other" (cluster external) sites
                #
                for rFile in $(ls "/hana/shared/$SID/$InstanceName/.crm_attribute."* 2>/dev/null); do
                    recover_site_attributes_from_file "$rFile"
                done
                case "$my_role" in
                    [12]:P:*:master:*  ) # primary is down or may not anser hdbsql query so drop analyze_hana_sync_status
                        ;;
                    [34]:P:*:*:*  ) # primary is up and should now be able to anser hdbsql query
                        if [ -f $DIR_EXECUTABLE/python_support/systemReplicationStatus.py ]; then
                            if [ "$promote_attr" = "PROMOTED" ]; then
                                analyze_hana_sync_statusSRS
                            fi
                        else
                            analyze_hana_sync_statusSQL
                        fi
                        ;;
                esac
                rem_role=$(get_hana_attribute "${remoteNode}" "${ATTR_NAME_HANA_ROLES[@]}")
                rem_clone_status=$(get_hana_attribute "${remoteNode}" "${ATTR_NAME_HANA_CLONE_STATE[@]}")
                if [ "$promote_attr" = "DEMOTED" -a "$rem_clone_status" = "PROMOTED" ]; then
                   case "$rem_role" in
                       [234]:P:* ) # dual primary, but other instance marked as PROMOTED by the cluster
                           lpa_check_lpt_status; again_lpa_rc=$?
                           if [ $again_lpa_rc -eq 2 ]; then
                              super_ocf_log info "DEC: Dual primary detected, other instance is PROMOTED and lpa stalemate ==> local restart"
                              lpa_set_lpt 10 "$NODENAME"
                              lpa_push_lpt 10
                              rc=$OCF_NOT_RUNNING
                           fi
                          ;;
                   esac
                fi
                super_ocf_log info "DEC: saphana_monitor_primary: scoring_crm_master($my_role,$my_sync)"
                scoring_crm_master "$my_role" "$my_sync"
            fi
            ;;
        * ) # UNDEFINED STATUS
            if ocf_is_probe; then
                rc=$OCF_NOT_RUNNING
            else
                if [ "$promoted" -eq 1 ]; then
                     rc=$OCF_FAILED_MASTER
                else
                     rc=$OCF_NOT_RUNNING
                fi
            fi
            ;;
    esac
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_monitor_secondary - monitor a hana clone instance
# params:   -
# globals:  OCF_*, ATTR_NAME_*, NODENAME
# saphana_monitor_secondary
#
function saphana_monitor_secondary()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=$OCF_ERR_GENERIC
    local promoted=0
    local init_attribute=0
    local lss
    #
    # OK, we are running as HANA SECONDARY
    #
    if ! lpa_get_lpt "${NODENAME}"; then
        super_ocf_log debug "DBG: 010 * lpa_set_lpt 10 $NODENAME"
        lpa_set_lpt  10 "$NODENAME"
        lpa_push_lpt 10
    fi
    promote_attr=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_CLONE_STATE[@]}")
    super_ocf_log debug "DBG: saphana_monitor_secondary: $ATTR_NAME_HANA_CLONE_STATE=$promote_attr"
    if [ -z "$promote_attr" ]; then
        init_attribute=1
        #  DONE: PRIO3: do we need to initialise also the DEMOTED attribute value?
        set_hana_attribute "${NODENAME}" "DEMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
        promoted=0;
    else
        case "$promote_attr" in
            PROMOTED ) # However - PROMOTED should only happen when coming back from maintenance
                promoted=1;
                ;;
            DEMOTED )  # This is the status we expect
                promoted=0;
                ;;
            WAITING* )  # We are WAITING for PRIMARY so not testing the HANA engine now but check for a new start
                if check_for_primary_master; then
                    super_ocf_log info "ACT: SECONDARY still in status WAITING - Primary now available - try a new start"
                    saphana_start_clone
                    rc=$?
                else
                    super_ocf_log info "ACT: saphana_monitor_clone: SECONDARY still in status WAITING - Primary is still missing"
                    return $OCF_SUCCESS
                fi
                promoted=0;
                ;;
            UNDEFINED | * )
                if ocf_is_probe; then
                   promoted=0;
                else
                   set_hana_attribute "${NODENAME}" "DEMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
                   promoted=0;
                fi
                ;;
        esac
    fi
    #
    super_ocf_log debug "DBG: saphana_monitor_clone: HANA_STATE_SECONDARY"
    #
    # old method was: saphana_monitor - new method is get_hana_landscape_status
    get_hana_landscape_status; lss=$?
    super_ocf_log debug "DBG: saphana_monitor_clone: get_hana_landscape_status=$lss"
    case "$lss" in
        0 ) # FATAL
            # DONE: PRIO1: Maybe we need to differ between 0 and 1. While 0 is a fatal sap error, 1 is down/error
            # TODO: PRIO3: is OCF_ERR_GENERIC best option?
            lpa_set_lpt  10 "$NODENAME"
            rc=$OCF_ERR_GENERIC
            ;;
        1 ) # ERROR
            lpa_set_lpt  10 "$NODENAME"
            rc=$OCF_NOT_RUNNING
            ;;
        2 | 3 | 4 ) # WARN INFO OK
            if [ "$promoted" -eq 1 ]; then
                # if the clone_state is still promoted for a secondary we send OCF_RUNNNG_MASTER to get it demoted
                rc=$OCF_RUNNING_MASTER
            else
                rc=$OCF_SUCCESS
            fi
            lpa_set_lpt  30 "$NODENAME"
            sync_attr=$(get_SRHOOK "$sr_name" "$NODENAME")
            local hanaOM=""
            local hanaOut1=""
            # TODO: PRIO 3: check, if using getParameter.py is the best option to analyze the set operationMode
            # DONE: PRIO 3: Should we default to logreplay for SAP HANA >= SPS11 ?
            hanaOut1=$(HANA_CALL --timeout 10 --use-su --cmd "python getParameter.py --key=global.ini/system_replication/operation_mode --sapcontrol=1")
            hanaFilter1=$(echo "$hanaOut1" | awk -F/ 'BEGIN {out=0} /^SAPCONTROL-OK: <begin>/ { out=1 } /^SAPCONTROL-OK: <end>/ { out=0 } /=/ {if (out==1) {print $3} }')
            hanaOM=$(echo "$hanaFilter1" | awk -F= '$1=="operation_mode" {print $2}')
            set_hana_attribute "${NODENAME}" "$hanaOM" "${ATTR_NAME_HANA_OPERATION_MODE[@]}"
            if [ -n "$remoteNode" ]; then
                set_hana_attribute "${remoteNode}" "$hanaOM" "${ATTR_NAME_HANA_OPERATION_MODE[@]}" # also set attribute for remoteNode (bsc1082974)
            fi
            super_ocf_log debug "DBG: sync_attr=$sync_attr"
            case "$sync_attr" in
                "SOK"   ) # This is a possible node to promote, when primary is missing
                    super_ocf_log info "DEC: secondary with sync status SOK ==> possible takeover node"
                    my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
                    my_sync=$(get_SRHOOK "$sr_name" "$NODENAME")
                    super_ocf_log info "DEC: saphana_monitor_secondary: scoring_crm_master($my_role,$my_sync)"
                    scoring_crm_master "$my_role" "$my_sync"
                    ;;
                "SFAIL" ) # This is currently NOT a possible node to promote
                    super_ocf_log info "DEC: secondary with sync status FAILED ==> EXCLUDE as possible takeover node"
                    set_crm_master -INFINITY
                    ;;
                * )     # Unknown sync status
                    super_ocf_log info "DEC: secondary has unexpected sync status $my_sync ==> RESCORE"
                    my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
                    my_sync=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_SYNC_STATUS[@]}")
                    super_ocf_log info "DEC: saphana_monitor_secondary: scoring_crm_master($my_role,$my_sync)"
                    scoring_crm_master "$my_role" "$my_sync"
                    ;;
            esac
            ;;
        * ) # UNDEFINED STATUS
            rc=$OCF_NOT_RUNNING
            ;;
    esac
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_monitor_clone - monitor a hana clone instance
# params:   -
# globals:  OCF_*, ATTR_NAME_*, HOSTNAME, HANA_STATE_*
# saphana_monitor_clone
#
function saphana_monitor_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    #
    # TODO: PRIO3: For the secondary, which is missing the primary (so in status WAITING) what is better:
    #       a) returning 7 here and force cluster a restart of the secondary
    #       b) starting the instance here inside the monitor -> may result in longer runtime, timeouts
    #
    # first check with the status function (OS tools) if there could be something like a SAP instance running
    # as we do not know here, if we are in primary or secondary state we do not want to start our monitoring
    # agents (sapstartsrv) on the wrong host
    local rc="$OCF_ERR_GENERIC"
    local promoted=0
    local init_attribute=0
    local lpaRc=0
    local mRc=0
    local myMaster=-1

    my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
    my_sync=$(get_SRHOOK "$sr_name" "$NODENAME")
    set_hana_attribute "$NODENAME" "-" "${ATTR_NAME_HANA_SRACTION_HISTORY[@]}"

    if ocf_is_probe; then
        super_ocf_log debug "DBG: PROBE ONLY"
    else
        super_ocf_log debug "DBG: REGULAR MONITOR"
    fi
    #
    # First check, if we are PRIMARY or SECONDARY
    #
    check_for_primary; primary_status=$?
    if [ $primary_status -eq $HANA_STATE_PRIMARY ]; then
        # FIX: bsc#919925 Leaving Node Maintenance stops HANA Resource Agent
        # TODO: PRIO1: Maybe we need a lpa-check here to
        if ocf_is_probe; then
            myMaster=$(get_crm_master); mRc=$?
            if [ $mRc -ne 0 ]; then
               set_crm_master 5
            elif [ $myMaster -eq -1 ]; then
               set_crm_master 5
            fi
        else
            saphana_check_local_instance
        fi
        saphana_monitor_primary; rc=$?
    else
        if [ $primary_status -eq $HANA_STATE_SECONDARY  ]; then
            if ! ocf_is_probe; then
                saphana_check_local_instance
            fi
            saphana_monitor_secondary; rc=$?
        else
            #
            # OK, we are neither HANA PRIMARY nor HANA SECONDARY
            #
            super_ocf_log warn "ACT: saphana_monitor_clone: HANA_STATE_DEFECT"
            # TODO: PRIO2: Or only set_crm_master -INFINITY ?
            rc=$OCF_ERR_GENERIC
        fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_monitor
# this function should never be called currently.
# it is intended for future releases which might support un-cloned resources
# for now it is only used to print a reasonable error message in case of
# non-cloned resources instead of 'command not found'
#
function saphana_monitor() {
    if ! is_clone; then
        super_ocf_log error "RA: resource is not defined as clone. This is not supported (OCF_ERR_UNIMPLEMENTED)"
        return "$OCF_ERR_UNIMPLEMENTED"
    else
        return "$OCF_SUCCESS"
    fi
}

#
# function: saphana_promote_clone - promote a hana clone
# params:   -
# globals:  OCF_*(r), NODENAME(r), HANA_STATE_*, SID(r), InstanceName(r),
# saphana_promote_clone:
#    In a multi-state configuration get Master being the primary OR by running hana takeover
#
function saphana_promote_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc="$OCF_SUCCESS";
    local hana_sync;
    local primary_status;
    #
    # first check, if we WILL be PRIMARY (checking HANA status)
    #
    set_hana_attribute "${NODENAME}" "PROMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
    check_for_primary; primary_status=$?
    #
    if [ $primary_status -eq $HANA_STATE_PRIMARY ]; then
        #
        # as we are already planned to be PRIMARY we only mark the node as PROMOTED
        #
        super_ocf_log info "ACT: Promoted $SID-$InstanceName as master (no hdbnsutil action needed)."
        rc=$OCF_SUCCESS;
    else
        if [ $primary_status -eq $HANA_STATE_SECONDARY ]; then
            #
            # we are SECONDARY and need to takeover ...  promote on the replica (secondary) side...
            # promote on the replica side...
            #
            hana_sync=$(get_SRHOOK "$sr_name" "$NODENAME")
            case "$hana_sync" in
                SOK )
                    super_ocf_log info "ACT: !!!!!!! Promote REPLICA $SID-$InstanceName to be primary. !!!!!!"
                    LPTloc=$(date '+%s')
                    # lpa_set_lpt 20 $remoteNode
                    lpa_set_lpt $LPTloc "$NODENAME"
                    lpa_push_lpt $LPTloc
                    # TODO: Get rid of the su by using a new interface:
                    # SAPSYSTEMNAME=SLE /usr/sap/SLE/HDB00/HDBSettings.sh hdbnsutil -sr_takeover ...
                    # TODO: Check beginning from which SPS does SAP support HDBSettings.sh?
                    # TODO: Limit the runtime of hdbnsutil -sr_takeover ????
                    # SAP_CALL
                    set_hana_attribute "$NODENAME" "T" "${ATTR_NAME_HANA_SRACTION[@]}"
                    set_hana_attribute "$NODENAME" "T" "${ATTR_NAME_HANA_SRACTION_HISTORY[@]}"
                    HANA_CALL --timeout inf --use-su --cmd "hdbnsutil -sr_takeover"
                    set_hana_attribute "$NODENAME" "-" "${ATTR_NAME_HANA_SRACTION[@]}"
                    #
                    # now gain check, if we are primary NOW
                    #
                    # TODO: PRIO3: check, if we need to destinguish between HANA_STATE_PRIMARY, HANA_STATE_SECONDARY, HANA_STATE_DEFECT
                    #
                    if check_for_primary; then
                        rc=$OCF_SUCCESS;
                    else
                        rc=$OCF_FAILED_MASTER
                    fi
                    ;;
                * )
                    super_ocf_log err "ACT: HANA SYNC STATUS IS NOT 'SOK' SO THIS HANA SITE COULD NOT BE PROMOTED"
                    rc=$OCF_ERR_GENERIC
                    ;;
            esac
        else
            #
            # neither PRIMARY nor SECONDARY - This clone instance seems to be broken!!
            # bsc#1027098 - do not stop SAP HANA if "only" HANA state is not correct
            # Let next monitor find, if that HANA instance is available or not
            rc="$OCF_SUCCESS";
        fi
    fi
    if [ $rc -eq $OCF_SUCCESS ]; then
        set_SRHOOK_PRIM
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: saphana_demote_clone - demote a hana clone instance
# params:   -
# globals:  OCF_*(r), NODENAME(r),
# saphana_demote_clone
#   the HANA System Replication (SR) runs in a multi-state configuration
#   While we could not change a HANA instance to be really demoted, we only mark the status for
#   correct monitor return codes
#
function saphana_demote_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=$OCF_ERR_GENERIC;
    set_hana_attribute "${NODENAME}" "DEMOTED" "${ATTR_NAME_HANA_CLONE_STATE[@]}"
    # bsc#1198127: let it fail, to get the resource stopped.
    my_role=$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")
    if [[ "$my_role" =~ 1:P:-:-:-:- ]]; then
        rc=$OCF_ERR_GENERIC
    else
        rc=$OCF_SUCCESS
    fi
    super_ocf_log info "ACT: Demoted $SID-$InstanceName."
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return $rc
}

#
# function: main - main function to operate
# params:   ACTION
# globals:  OCF_*(r), SID(w), sidadm(w), InstanceName(w), SAPVIRHOST(w), DIR_EXECUTABLE(w),
# globals:  SAPSTARTSRV(w), SAPCONTROL(w), DIR_PROFILE(w), SAPSTARTPROFILE(w), ACTION(w), CLACT(w), ra_rc(rw), $0(r), %ENV(r)
#

## GLOBALS
SID=''
sid=''
sidadm=''
InstanceName=""
InstanceNr=""
SAPVIRHOST=""
DIR_EXECUTABLE=""
SAPSTARTSRV=""
SAPCONTROL=""
DIR_PROFILE=""
SAPSTARTPROFILE=""
declare -u SAPHanaFilter='ra-act-dec-lpa'


if [ $# -ne 1 ]
then
  saphana_usage
  exit $OCF_ERR_ARGS
fi

ACTION=$1
if [ "$ACTION" = "status" ]; then
    ACTION=monitor
fi

# These operations don't require OCF parameters to be set
# TODO: PRIO5: check, if notify is still not needing OCF parameters
case "$ACTION" in
    usage|methods)  saphana_$ACTION
                    exit $OCF_SUCCESS;;
    meta-data)      saphana_meta_data
                    exit $OCF_SUCCESS;;
    notify)         #saphana_notify
                    exit $OCF_SUCCESS;;
    *);;
esac

super_ocf_log info "RA ==== initialization (${SAPHanaVersion:-}) (${SECONDS}s)===="
saphana_init

if ! ocf_is_root
then
    super_ocf_log err "ACT: $0 must be run as root"
    exit $OCF_ERR_PERM
fi

# parameter check
if  [ -z "$OCF_RESKEY_SID" ]
then
    super_ocf_log err "ACT: Please set parameter SID!"
    exit $OCF_ERR_ARGS
fi

if  [ -z "$OCF_RESKEY_InstanceNumber" ]
then
    super_ocf_log err "ACT: Please set parameter InstanceNumber!"
    exit $OCF_ERR_ARGS
fi

if is_clone
then
    CLACT=_clone
else
    if [ "$ACTION" = "promote" -o "$ACTION" = "demote" ]
    then
        super_ocf_log err "ACT: $ACTION called in a non multi-state environment"
        exit $OCF_ERR_ARGS
    fi
fi

# What kind of method was invoked?
super_ocf_log info "RA ==== begin action $ACTION$CLACT ($SAPHanaVersion) (${SECONDS}s)===="
ra_rc=$OCF_ERR_UNIMPLEMENTED
case "$ACTION" in
    start|stop|monitor|promote|demote) # Standard controlling actions
        saphana_$ACTION$CLACT
        ra_rc=$?
        ;;
    validate-all)
        saphana_validate
        ra_rc=$?
        ;;
    lpa_check)
        lpa_check_lpt_status
        ra_rc=$?
        ;;
    reload)
        ra_rc=$OCF_SUCCESS
        ;;
    *)  # seems to be an unknown request
        saphana_methods
        ra_rc=$OCF_ERR_UNIMPLEMENTED
        ;;
esac
super_ocf_log debug "DBG: ==== SAPHanaFilter=$SAPHanaFilter"
super_ocf_log info "RA ==== end action $ACTION$CLACT with rc=${ra_rc} ($SAPHanaVersion) (${SECONDS}s)===="
exit ${ra_rc}
# set ts=4 sw=4 sts=4 et
